<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ReactSourceEffectListDebug</title>
      <link href="/2022/05/04/ReactSourceEffectListDebug/"/>
      <url>/2022/05/04/ReactSourceEffectListDebug/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>React对Fiber树进行遍历标记更新之后，需要在<strong>真实DOM中进行实际操作</strong>，已经知道会在<code>commit</code>阶段，那么React是怎么找到需要更新的Fiber的呢？<ul><li>从Fiber树开始从头遍历会使得性能很低</li></ul></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><strong>React在对Fiber进行修改的时候，会同时维护一个特殊的<code>EffectList</code>用来保存需要修改的Fiber</strong><ul><li><code>EffectList</code>就是一个链表，每一个节点的值是一个Fiber</li><li>每个Fiber都有自己的<code>firstEffect</code>、<code>lastEffect</code>，也就是链表的头节点和尾节点</li></ul></li></ul><h3 id="学习实例"><a href="#学习实例" class="headerlink" title="学习实例"></a>学习实例</h3><ul><li><p>DEMO如下（还是Diff源码学习中的案例）</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Test</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState&lt;<span class="title class_">ListItemType</span>[]&gt;([</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&quot;22 a&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;a&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&quot;13 b&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;b&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&quot;21 c&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;c&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&quot;12 d&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;d&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&quot;32 e&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;e&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&quot;44 f&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;f&quot;</span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;list.map((item) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          return item ? <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.key&#125;</span>&gt;</span>&#123;item.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span> : null;</span></span><br><span class="line"><span class="language-xml">        &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          debugger;</span></span><br><span class="line"><span class="language-xml">          setList((prev) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">            let newArr: ListItemType[] = [];</span></span><br><span class="line"><span class="language-xml">            prev.splice(Math.floor(Math.random() * 5), 1);</span></span><br><span class="line"><span class="language-xml">            newArr.push(...prev.splice(Math.floor(Math.random() * 4), 1));</span></span><br><span class="line"><span class="language-xml">            newArr = newArr.concat(prev);</span></span><br><span class="line"><span class="language-xml">            return newArr;</span></span><br><span class="line"><span class="language-xml">          &#125;);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        random all</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="EffectList"><a href="#EffectList" class="headerlink" title="EffectList"></a>EffectList</h2><h3 id="DEOM更新状态"><a href="#DEOM更新状态" class="headerlink" title="DEOM更新状态"></a>DEOM更新状态</h3><ul><li>DEMO运行点击按钮后将要更新的状态，关键更新如下<ul><li>e序列移动到第一个位置</li><li>删除c序列</li></ul></li></ul><img src="/2022/05/04/ReactSourceEffectListDebug/111.png" class="" title="DEMO更新状态"><h3 id="EffectList执行时机"><a href="#EffectList执行时机" class="headerlink" title="EffectList执行时机"></a>EffectList执行时机</h3><ul><li>最后在<code>commit</code>阶段，修改真实DOM时有这样的代码（已省略部分代码）<ul><li><strong>就是去循环获取<code>EffectList</code>，根据每一个<code>Effect</code>的<code>flags</code>去决定修改方式</strong></li><li><strong>会通过FiberRoot的<code>firstEffect</code>获取第一个effect，然后进入循环</strong></li><li><strong>每一个Effect都是一个Fiber</strong></li><li><strong>一个典型的空间换取时间的优化机制</strong></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">setCurrentFiber</span>(nextEffect); <span class="comment">// 设置Fiber环境</span></span><br><span class="line">    <span class="keyword">var</span> flags = nextEffect.<span class="property">flags</span>; <span class="comment">// 更新flags</span></span><br><span class="line">    <span class="keyword">var</span> primaryFlags = flags &amp; (<span class="title class_">Placement</span> | <span class="title class_">Update</span> | <span class="title class_">Deletion</span> | <span class="title class_">Hydrating</span>); <span class="comment">// 计算flags</span></span><br><span class="line">    <span class="keyword">switch</span> (primaryFlags) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">Placement</span>: <span class="comment">// 移动节点的effect操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title function_">commitPlacement</span>(nextEffect);ct.<span class="property">flags</span> &amp;= ~<span class="title class_">Placement</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">resetCurrentFiber</span>(); <span class="comment">// 重置Fiber环境</span></span><br><span class="line">    nextEffect = nextEffect.<span class="property">nextEffect</span>; <span class="comment">// 获取下一个effect，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EffectList实例"><a href="#EffectList实例" class="headerlink" title="EffectList实例"></a>EffectList实例</h3><ul><li>案例更新状态的<code>EffectList</code>如下</li></ul><img src="/2022/05/04/ReactSourceEffectListDebug/222.png" class="" title="EffectList链表"><ul><li><p><strong>即<code>c-&gt;a-&gt;b-&gt;d-&gt;button</code>这个<code>effectlist</code>在这次更新状态中生成，<code>commit</code>阶段遍历这个链表，从而一个一个更新真实DOM</strong></p></li><li><p><strong>可以看到没有<code>e</code>节点在<code>EffectList</code>中如同之前Diff中说过的，React对节点只进行右移操作，所以<code>e</code>节点保持原位即可</strong></p></li></ul><h3 id="EffectList生成机制"><a href="#EffectList生成机制" class="headerlink" title="EffectList生成机制"></a>EffectList生成机制</h3><ul><li><p><strong>主要继承逻辑就在<code>completeWork</code>代码中，即Fiber节点的<code>complete</code>阶段</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (returnFiber !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    (returnFiber.<span class="property">flags</span> &amp; <span class="title class_">Incomplete</span>) === <span class="title class_">NoFlags</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (returnFiber.<span class="property">firstEffect</span> === <span class="literal">null</span>) &#123; <span class="comment">// 父Fiber不存在EffectList时</span></span><br><span class="line">        returnFiber.<span class="property">firstEffect</span> = completedWork.<span class="property">firstEffect</span>; <span class="comment">// 直接继承子Fiber的EffectList</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completedWork.<span class="property">lastEffect</span> !== <span class="literal">null</span>) &#123; <span class="comment">// 子Fiber存在EffectList</span></span><br><span class="line">        <span class="keyword">if</span> (returnFiber.<span class="property">lastEffect</span> !== <span class="literal">null</span>) &#123; <span class="comment">// 父Fiber也存在EffectList</span></span><br><span class="line">            returnFiber.<span class="property">lastEffect</span>.<span class="property">nextEffect</span> = completedWork.<span class="property">firstEffect</span>; <span class="comment">// 让父Fiber的EffectList的最后一个Effect连接子Fiber的Effect，实际上就是子链表接到父链表后面</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        returnFiber.<span class="property">lastEffect</span> = completedWork.<span class="property">lastEffect</span>; <span class="comment">// 保证父链表的尾指针指向最后一个Effect</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> flags = completedWork.<span class="property">flags</span>; <span class="comment">// 获取当前Fiber的更新标识（flags）</span></span><br><span class="line">    <span class="keyword">if</span> (flags &gt; <span class="title class_">PerformedWork</span>) &#123; <span class="comment">// 如果是需要操作DOM的更新</span></span><br><span class="line">        <span class="comment">// 把当前Fiber添加到父Fiber的EffectList中</span></span><br><span class="line">        <span class="keyword">if</span> (returnFiber.<span class="property">lastEffect</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">            returnFiber.<span class="property">lastEffect</span>.<span class="property">nextEffect</span> = completedWork;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            returnFiber.<span class="property">firstEffect</span> = completedWork;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置父Fiber的尾指针</span></span><br><span class="line">        returnFiber.<span class="property">lastEffect</span> = completedWork;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>PerformedWork</code>的值是1，而不需要变动的Fiber所标识的flags是0（例如本例的节点<code>e</code>），其余都会标识都会大于<code>PerformedWork</code>这样就把特定的Fiber连接到了<code>EffectList</code>中</strong></p></li><li><p><strong><code>a b d</code>节点的flags早在父Fiber在Diff孩子节点的时候就已经标记了，具体如下</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;</span><br><span class="line">    newFiber.<span class="property">flags</span> = <span class="title class_">Placement</span>; <span class="comment">// 标记为移动</span></span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">&#125; <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> oldIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没错，就是上个Diff源码学习中的PlaceChild函数(检查节点是否需要移动)中执行的操作</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>c</code>节点也会在Diff时标记，并且直接计入<code>EffectList</code>，具体如下</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> last = returnFiber.<span class="property">lastEffect</span>;</span><br><span class="line">last.<span class="property">nextEffect</span> = childToDelete;</span><br><span class="line">returnFiber.<span class="property">lastEffect</span> = childToDelete;</span><br><span class="line"><span class="comment">// 就在Diff操作的最后阶段执行，用于标记需要删除的childFiber</span></span><br></pre></td></tr></table></figure></li><li><p><strong>由于Fiber树的遍历以及完成机制，<code>completeWork</code>到FiberRoot时，也就完成了整个<code>EffectList</code>，这样在<code>commit</code>阶段只需要获取FiberRoot的<code>firstEffect</code>，即可开始遍历<code>EffectList</code>进行更新操作</strong></p><ul><li>不属于真实DOM的Effect也是同样的机制（例如：<code>useEffect</code>注册的函数）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactSourceDiffDebug</title>
      <link href="/2022/04/06/ReactSourceDiffDebug/"/>
      <url>/2022/04/06/ReactSourceDiffDebug/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>React源码版本：<code>17.0.2</code></p></li><li><p>DEMO如下</p></li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Test</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="keyword">const</span> [list, setList] = useState&lt;<span class="title class_">ListItemType</span>[]&gt;([</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&quot;22 a&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;a&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&quot;13 b&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;b&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&quot;21 c&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;c&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&quot;12 d&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;d&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&quot;32 e&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;e&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">text</span>: <span class="string">&quot;44 f&quot;</span>, <span class="attr">key</span>: <span class="string">&quot;f&quot;</span> &#125;,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;list.map((item) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          return item ? <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.key&#125;</span>&gt;</span>&#123;item.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span> : null;</span></span><br><span class="line"><span class="language-xml">        &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          debugger;</span></span><br><span class="line"><span class="language-xml">          setList((prev) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">            let newArr: ListItemType[] = [];</span></span><br><span class="line"><span class="language-xml">            // 点击按钮之后，随机删除一个li节点，随机挑选一个节点放到第一行</span></span><br><span class="line"><span class="language-xml">            prev.splice(Math.floor(Math.random() * 5), 1);</span></span><br><span class="line"><span class="language-xml">            newArr.push(...prev.splice(Math.floor(Math.random() * 4), 1));</span></span><br><span class="line"><span class="language-xml">            newArr = newArr.concat(prev);</span></span><br><span class="line"><span class="language-xml">            return newArr;</span></span><br><span class="line"><span class="language-xml">          &#125;);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        random all</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Diff解析"><a href="#Diff解析" class="headerlink" title="Diff解析"></a>Diff解析</h2><h3 id="Debug时机"><a href="#Debug时机" class="headerlink" title="Debug时机"></a>Debug时机</h3><ul><li><strong>首次渲染之后</strong>，点击<code>random all</code>按钮随机处理<code>state</code>之后执行<code>performSyncWorkOnRoot</code>函数时进行Debug</li><li><strong><code>Test</code>组件根据<code>hook</code>获取最新的<code>state</code>，后续先对Fiber更新</strong></li></ul><h3 id="reconcileChildren"><a href="#reconcileChildren" class="headerlink" title="reconcileChildren"></a>reconcileChildren</h3><ul><li><code>beginWork</code>对<code>ul</code>标签进行处理时，<strong>会对其<code>children</code>进行一次Diff操作</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params">current, workInProgress, nextChildren, renderLanes</span>) &#123;</span><br><span class="line">    <span class="comment">// current是当前已经渲染过的Fiber（workInProcess.alternate）</span></span><br><span class="line">    <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个是初始化时进行的操作</span></span><br><span class="line">        workInProgress.<span class="property">child</span> = <span class="title function_">mountChildFibers</span>(workInProgress, <span class="literal">null</span>, nextChildren, renderLanes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这个是Fiber已经存在时的处理（后续更新）</span></span><br><span class="line">        workInProgress.<span class="property">child</span> = <span class="title function_">reconcileChildFibers</span>(workInProgress, current.<span class="property">child</span>, nextChildren, renderLanes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>reconcileChildFibers</code>针对不同的<code>child</code>调用不同的函数去处理<code>Fiber</code>，<strong>这里我们主要看 React 对多个同级DOM的删除、更新怎么处理的（DOM Diff）</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildFibers</span>(<span class="params">returnFiber, currentFirstChild, newChild, lanes</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> isObject = <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (newChild.<span class="property">$$typeof</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里处理单个child</span></span><br><span class="line">            <span class="keyword">case</span> <span class="attr">REACT_ELEMENT_TYPE</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">placeSingleChild</span>(<span class="title function_">reconcileSingleElement</span>(returnFiber, currentFirstChild, newChild, lanes));</span><br><span class="line">   <span class="comment">// ......... 例如：Fragment</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// child是字符串或者数字的处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">placeSingleChild</span>(<span class="title function_">reconcileSingleTextNode</span>(returnFiber, currentFirstChild, <span class="string">&#x27;&#x27;</span> + newChild, lanes));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// DOM Diff</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isArray$1</span>(newChild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reconcileChildrenArray</span>(returnFiber, currentFirstChild, newChild, lanes);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...........其他类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">deleteRemainingChildren</span>(returnFiber, currentFirstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reconcileChildrenArray"><a href="#reconcileChildrenArray" class="headerlink" title="reconcileChildrenArray"></a>reconcileChildrenArray</h3><ul><li><strong><code>reconcileChildrenArray</code>对<code>childs</code>进行处理（创建或者复用DOM）</strong></li><li>算法浅析如下：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildrenArray</span>(<span class="params">returnFiber, currentFirstChild, newChildren, lanes</span>) &#123;</span><br><span class="line"><span class="comment">// 首先对每个child的key进行验证，是否重复等</span></span><br><span class="line">    <span class="comment">// 代码省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> resultingFirstChild = <span class="literal">null</span>; <span class="comment">// 最后返回的Fiber，用于构建Fiber树</span></span><br><span class="line">    <span class="keyword">var</span> previousNewFiber = <span class="literal">null</span>; <span class="comment">// 保存遍历过程中的上一个newFiber</span></span><br><span class="line">    <span class="keyword">var</span> oldFiber = currentFirstChild; <span class="comment">// 第一个oldFiber</span></span><br><span class="line">    <span class="comment">// React只允许DOM节点复用时向右移动</span></span><br><span class="line">    <span class="comment">// 只要oldFiber的下标比lastPlacedIndex大，就说明这个节点需要右移</span></span><br><span class="line">    <span class="comment">// 具体算法看 placeChild 这个函数</span></span><br><span class="line">    <span class="keyword">var</span> lastPlacedIndex = <span class="number">0</span>; <span class="comment">// 标记newFiber中最新已处理节点的下标</span></span><br><span class="line">    <span class="keyword">var</span> newIdx = <span class="number">0</span>; <span class="comment">// 新Child的索引</span></span><br><span class="line">    <span class="keyword">var</span> nextOldFiber = <span class="literal">null</span>; <span class="comment">// 下一个oldFiber</span></span><br><span class="line"><span class="comment">// 第一次遍历，oldChild和newChild同步遍历</span></span><br><span class="line">    <span class="comment">// 比如：oldChild[0]和newChild[0]尝试是否可以复用</span></span><br><span class="line">    <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldFiber.<span class="property">index</span> &gt; newIdx) &#123; <span class="comment">// 旧节点在新节点右边，不了解这种情况什么时候发生...</span></span><br><span class="line">            nextOldFiber = oldFiber;</span><br><span class="line">            oldFiber = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 获取下个旧节点，比如oldChild[0]的sibling就是oldChild[1]，Fiber树的原因</span></span><br><span class="line">            nextOldFiber = oldFiber.<span class="property">sibling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 尝试复用旧Fiber</span></span><br><span class="line">        <span class="comment">// updateSlot内部通过检测key值是否相同来判断是否能够复用</span></span><br><span class="line">        <span class="comment">// 如果能够复用，oldFiber保留，并根据newChild更新下属性即可</span></span><br><span class="line">        <span class="comment">// 同时还有处理别的newFiber的代码，比如newFiber是个textNode，或者newFiber是个Fragment</span></span><br><span class="line">        <span class="keyword">var</span> newFiber = <span class="title function_">updateSlot</span>(returnFiber, oldFiber, newChildren[newIdx], lanes);</span><br><span class="line">    <span class="comment">//如果不能复用，newFiber为null，此时直接跳出第一次循环</span></span><br><span class="line">        <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">                oldFiber = nextOldFiber;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 需要删除这个Fiber</span></span><br><span class="line">        <span class="keyword">if</span> (shouldTrackSideEffects) &#123; <span class="comment">// shouldTrackSideEffetcs在更新操作中始终为true</span></span><br><span class="line">            <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.<span class="property">alternate</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="title function_">deleteChild</span>(returnFiber, oldFiber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//更新lastPlacedIndex</span></span><br><span class="line">        lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取第一个newFiber用于构建Fiber树，并将上一个newFiber的sibling指向这个newFiber</span></span><br><span class="line">        <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123; <span class="comment">// 第一次循环才会进入这个</span></span><br><span class="line">            resultingFirstChild = newFiber;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            previousNewFiber.<span class="property">sibling</span> = newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">// 进入下一次循环，更新标识变量</span></span><br><span class="line">        previousNewFiber = newFiber;</span><br><span class="line">        oldFiber = nextOldFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newIdx === newChildren.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="comment">//.... 新Child遍历完毕，说明剩下的oldFiber在新DOM树中不存在，直接删除（这里只是标记，DOM操作都在 commitRoot 函数里）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//.... 旧Child遍历完毕，说明剩下的newFiber是新添加的，没有可复用Fiber，直接创建Fiber即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历旧Fiber创建set，键为key值，值为Fiber</span></span><br><span class="line">    <span class="keyword">var</span> existingChildren = <span class="title function_">mapRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line"><span class="comment">// 第二次遍历，对于每一个newChild，直接从set里找有没有key值相同可以复用的Fiber</span></span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">        <span class="comment">// updateFromMap 直接去上面生成的map里面去找有没有key值相同的Fiber，如果有直接复用，否则直接新建一个</span></span><br><span class="line">        <span class="keyword">var</span> _newFiber2 = <span class="title function_">updateFromMap</span>(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);</span><br><span class="line">    <span class="comment">// 删除map中的oldFiber</span></span><br><span class="line">        <span class="keyword">if</span> (_newFiber2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_newFiber2.<span class="property">alternate</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">                    existingChildren.<span class="title function_">delete</span>(_newFiber2.<span class="property">key</span> === <span class="literal">null</span> ? newIdx : _newFiber2.<span class="property">key</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">// 更新lastPlacedIndex</span></span><br><span class="line">            lastPlacedIndex = <span class="title function_">placeChild</span>(_newFiber2, lastPlacedIndex, newIdx);</span><br><span class="line">  <span class="comment">// 和第一次遍历时的操作一样</span></span><br><span class="line">            <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">                resultingFirstChild = _newFiber2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                previousNewFiber.<span class="property">sibling</span> = _newFiber2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            previousNewFiber = _newFiber2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 删除没有用到的旧ChildFiber</span></span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        existingChildren.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">child</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">deleteChild</span>(returnFiber, child);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>两次遍历</strong><ul><li><strong>第一次同步遍历找可复用节点</strong></li><li><strong>第二次利用<code>Set</code>找可复用节点</strong></li></ul></li></ul><h3 id="placeChild"><a href="#placeChild" class="headerlink" title="placeChild"></a>placeChild</h3><ul><li><strong>用于比较<code>newFiber</code>和<code>oldFiber</code>的<code>index</code>，来确定<code>newFiber</code>具体的DOM操作</strong></li><li>代码解析如下：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">placeChild</span>(<span class="params">newFiber, lastPlacedIndex, newIndex</span>) &#123;</span><br><span class="line">    newFiber.<span class="property">index</span> = newIndex; <span class="comment">// 设置newFiber的index</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldTrackSideEffects) &#123; <span class="comment">// 初始化时不需要标记节点是否需要移动</span></span><br><span class="line">        <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> current = newFiber.<span class="property">alternate</span>; <span class="comment">// oldFiber</span></span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> oldIndex = current.<span class="property">index</span>; <span class="comment">// oldFiber下标</span></span><br><span class="line">        <span class="keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;</span><br><span class="line">            <span class="comment">// 旧节点在最新节点下标左边，说明在新DOM中需要右移</span></span><br><span class="line">            newFiber.<span class="property">flags</span> = <span class="title class_">Placement</span>; <span class="comment">// 标记</span></span><br><span class="line">            <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回覆盖lastPlacedIndex</span></span><br><span class="line">            <span class="keyword">return</span> oldIndex; <span class="comment">// 这个节点不需要移动，在更新后的DOM树中保持原位即可(因为React中同级DOM节点Diff时只右移)，标记下这是新DOM中最新Fiber的index</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 插入操作</span></span><br><span class="line">        newFiber.<span class="property">flags</span> = <span class="title class_">Placement</span>;</span><br><span class="line">        <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commitMutationEffects"><a href="#commitMutationEffects" class="headerlink" title="commitMutationEffects"></a>commitMutationEffects</h3><ul><li><strong><code>commitRoot</code>阶段用于更新真实DOM的函数，看下<code>Diff</code>阶段标记Fiber之后，真实DOM怎么操作</strong></li><li><strong><code>nextEffect</code>构成一个更新链（所有需要操作的Fiber会形成一个链表，一个接一个处理），还没搞懂这个根据什么顺序连接起来……</strong></li><li>已省略部分代码</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitMutationEffects</span>(<span class="params">root, renderPriorityLevel</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">setCurrentFiber</span>(nextEffect); <span class="comment">// nextEffect 就是需要更新的Fiber</span></span><br><span class="line">    <span class="keyword">var</span> flags = nextEffect.<span class="property">flags</span>; <span class="comment">// flags Fiber的标记，比如placeChild设置的移动标记</span></span><br><span class="line">    <span class="keyword">var</span> primaryFlags = flags &amp; (<span class="title class_">Placement</span> | <span class="title class_">Update</span> | <span class="title class_">Deletion</span> | <span class="title class_">Hydrating</span>); <span class="comment">// 计算flags</span></span><br><span class="line">    <span class="keyword">switch</span> (primaryFlags) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">Placement</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="title function_">commitPlacement</span>(nextEffect); <span class="comment">// 移动节点的函数</span></span><br><span class="line">          nextEffect.<span class="property">flags</span> &amp;= ~<span class="title class_">Placement</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">PlacementAndUpdate</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">Hydrating</span>:</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">HydratingAndUpdate</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">Update</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">Deletion</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">resetCurrentFiber</span>();</span><br><span class="line">    nextEffect = nextEffect.<span class="property">nextEffect</span>; <span class="comment">// 获取下一个需要更新的Fiber</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commitPlacement"><a href="#commitPlacement" class="headerlink" title="commitPlacement"></a>commitPlacement</h3><ul><li><strong><code>commitPlacement</code>函数内部真正调用DOM操作处理DOM节点</strong></li><li>已省略部分代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">commitPlacement</span>(<span class="params">finishedWork</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> parentFiber = <span class="title function_">getHostParentFiber</span>(finishedWork); <span class="comment">// 获取父级DOM，本DEMO中就是 ul 节点</span></span><br><span class="line">  <span class="keyword">var</span> parent;</span><br><span class="line">  <span class="keyword">var</span> isContainer;</span><br><span class="line">  <span class="keyword">var</span> parentStateNode = parentFiber.<span class="property">stateNode</span>; <span class="comment">// 获取父节点的真实DOM</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (parentFiber.<span class="property">tag</span>) &#123; <span class="comment">//根据父节点类型，设置变量</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostComponent</span>: <span class="comment">// 本DEMO中会走这个</span></span><br><span class="line">      parent = parentStateNode;</span><br><span class="line">      isContainer = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostRoot</span>:</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostPortal</span>:</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FundamentalComponent</span>:</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="comment">// ... 没找到合适的节点类型而报错</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> before = <span class="title function_">getHostSibling</span>(finishedWork); <span class="comment">// 获取Fiber的sibling链中第一个flags不是Placement的节点(即不需要移动的节点)</span></span><br><span class="line">  <span class="keyword">if</span> (isContainer) &#123;</span><br><span class="line">    <span class="title function_">insertOrAppendPlacementNodeIntoContainer</span>(finishedWork, before, parent);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 本DEMO调用这个函数</span></span><br><span class="line">    <span class="title function_">insertOrAppendPlacementNode</span>(finishedWork, before, parent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>最后的<code>insertOrAppendPlacementNode</code>会根据<code>before</code>变量是否存在执行以下操作：</strong><ul><li><strong><code>before</code>存在，直接调用<code>parent.insertBefore(current,before)</code>将<code>current</code>放到<code>before</code>之前</strong></li><li><strong><code>before</code>不存在，直接调用<code>parent.appendChild(current)</code></strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Diff </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactSourceHookDebug</title>
      <link href="/2022/03/27/ReactSourceHookDebug/"/>
      <url>/2022/03/27/ReactSourceHookDebug/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>React源码版本：<code>17.0.2</code></li><li>Debug Demo 如下：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Test</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;effect!&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        setNum((prev) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          return prev + 1;</span></span><br><span class="line"><span class="language-xml">        &#125;);</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    &gt;</span></span><br><span class="line"><span class="language-xml">      &#123;num&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>本文章记录学习React Hook源码时的一些收获</strong></li></ul><h2 id="Hook流程"><a href="#Hook流程" class="headerlink" title="Hook流程"></a>Hook流程</h2><h3 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h3><ul><li>跳过<code>rootContainer</code>的创建，lanes算法初始化等等代码，首先关注<code>&lt;Test /&gt;</code>组件的Fiber初始化，根据DEMO，<strong>此时<code>beginWork</code>已经处理rootFiber并创建了<code>&lt;Test /&gt;</code>组件的Fiber</strong>，现在要对其进行初始化</li></ul><p>此时<code>&lt;Test /&gt;</code>的Fiber（已省略部分属性）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">key</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">/*可以看到webpack处理后的Test函数中的JSX都被jsxDev解析函数包裹*/</span></span><br><span class="line">  <span class="attr">elementType</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">_s</span>();</span><br><span class="line">    <span class="keyword">const</span> [num, setNum] = (<span class="number">0</span>,react__WEBPACK_IMPORTED_MODULE_0__.<span class="property">useState</span>)(<span class="number">0</span>);</span><br><span class="line">    (<span class="number">0</span>,react__WEBPACK_IMPORTED_MODULE_0__.<span class="property">useEffect</span>)(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">debugger</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;effect!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/*#__PURE__*/</span>(<span class="number">0</span>,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.<span class="property">jsxDEV</span>)(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">debugger</span>;</span><br><span class="line">        <span class="title function_">setNum</span>(<span class="function"><span class="params">prev</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> prev + <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">children</span>: num</span><br><span class="line">    &#125;, <span class="built_in">void</span> <span class="number">0</span>, <span class="literal">false</span>, &#123;</span><br><span class="line">      <span class="attr">fileName</span>: _jsxFileName,</span><br><span class="line">      <span class="attr">lineNumber</span>: <span class="number">59</span>,</span><br><span class="line">      <span class="attr">columnNumber</span>: <span class="number">5</span></span><br><span class="line">    &#125;, <span class="literal">undefined</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">type</span>: <span class="function">() =&gt;</span> &#123;<span class="comment">/*webpack处理后的Test函数和elementType一致*/</span>&#125;,</span><br><span class="line">  <span class="attr">stateNode</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">return</span>: &#123;<span class="comment">/*rootFiber*/</span>&#125;,</span><br><span class="line">  <span class="attr">child</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">sibling</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">index</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">ref</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">pendingProps</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">memoizedProps</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">updateQueue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">dependencies</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">mode</span>: <span class="number">8</span>,</span><br><span class="line">  <span class="attr">flags</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">nextEffect</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">firstEffect</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">lastEffect</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">alternate</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的调用栈</p><img src="/2022/03/27/ReactSourceHookDebug/11.png" class="" title="调用栈"><ul><li>Fiber的tag为2，由如下源码可知，是因为React还不知道是<code>class</code>还是<code>function</code></li></ul><blockquote><p>var IndeterminateComponent &#x3D; 2; <em>&#x2F;&#x2F; Before we know whether it is function or class</em></p></blockquote><h3 id="renderWithHooks"><a href="#renderWithHooks" class="headerlink" title="renderWithHooks"></a>renderWithHooks</h3><ul><li>后续调用函数去专门处理tag为2的组件，以下是React判断组件时<code>class</code>还是<code>function</code>的代码</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span> &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">render</span> === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">//是class组件，...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后保存Fiber进行处理</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactCurrentOwner</span>$<span class="number">1.</span>current = workInProgress; <span class="comment">// workInProgress 就是当前处理的Fiber</span></span><br><span class="line">value = <span class="title function_">renderWithHooks</span>(<span class="literal">null</span>, workInProgress, <span class="title class_">Component</span>, props, context, renderLanes);</span><br></pre></td></tr></table></figure><ul><li><strong>之后会调用这个代码，为当前环境设置hook，之后会使用<code>throwError</code>版本覆盖，这也是为什么hook只能在<code>function</code>组件中使用的原因</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactCurrentDispatcher</span>$<span class="number">1.</span>current = <span class="title class_">HooksDispatcherOnMountInDEV</span>;</span><br><span class="line"><span class="comment">// 而HooksDispatchOnMountInDEV则保存了所有React的hook（当然也有update版本）</span></span><br></pre></td></tr></table></figure><p>下图为部分hook</p><img src="/2022/03/27/ReactSourceHookDebug/22.png" class="" title="部分hook"><ul><li>之后调用<code>function</code>组件，执行用户代码，获取<code>child</code></li></ul><p>调用栈如图</p><img src="/2022/03/27/ReactSourceHookDebug/33.png" class="" title="调用栈"><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useState源码 省略部分源码</span></span><br><span class="line"><span class="attr">useState</span>: <span class="keyword">function</span> (<span class="params">initialState</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> prevDispatcher = <span class="title class_">ReactCurrentDispatcher</span>$<span class="number">1.</span>current; <span class="comment">// 这里就会获取正常运行的Hook代码</span></span><br><span class="line">    <span class="title class_">ReactCurrentDispatcher</span>$<span class="number">1.</span>current = <span class="title class_">InvalidNestedHooksDispatcherOnMountInDEV</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">mountState</span>(initialState); <span class="comment">// useState主要执行的逻辑</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="title class_">ReactCurrentDispatcher</span>$<span class="number">1.</span>current = prevDispatcher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接受用户的值作为<code>initialState</code>，并最后调用<code>mountState</code></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mountState 源码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountState</span>(<span class="params">initialState</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> hook = <span class="title function_">mountWorkInProgressHook</span>(); <span class="comment">// 生成hook对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="comment">// 如果initialState是函数，就会执行并获取返回值</span></span><br><span class="line">        <span class="comment">// $FlowFixMe: Flow doesn&#x27;t like mixed types</span></span><br><span class="line">        initialState = <span class="title function_">initialState</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hook.<span class="property">memoizedState</span> = hook.<span class="property">baseState</span> = initialState; <span class="comment">// 获取初始值，并保存（闭包）</span></span><br><span class="line">    <span class="keyword">var</span> queue = hook.<span class="property">queue</span> = &#123;</span><br><span class="line">        <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">dispatch</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">lastRenderedReducer</span>: basicStateReducer, <span class="comment">// 更新函数</span></span><br><span class="line">        <span class="attr">lastRenderedState</span>: initialState</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> dispatch = queue.<span class="property">dispatch</span> = dispatchAction.<span class="title function_">bind</span>(<span class="literal">null</span>, currentlyRenderingFiber$<span class="number">1</span>, queue); <span class="comment">// useState返回的更新函数，已经硬绑定了2个参数</span></span><br><span class="line">    <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch]; <span class="comment">// 返回形式，也是为什么使用 const [val,setVal] = useState(0); 的原因</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先初始化hook对象，用来保存<code>state</code>数据、调用队列等</p></li><li><p><strong><code>dispatch</code>函数绑定了当前Fiber，并且调用<code>lastRenderedReducer</code>（也就是<code>basicStateReducer</code>），最后进行<code>scheduleUpdateOnFiber</code>（发起调度更新）</strong></p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已省略大部分代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dispatchAction</span>(<span class="params">fiber, queue, action</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> currentState = queue.<span class="property">lastRenderedState</span>; <span class="comment">// 获取保存的state</span></span><br><span class="line">        <span class="keyword">var</span> eagerState = <span class="title function_">lastRenderedReducer</span>(currentState, action); <span class="comment">// 获取新的state</span></span><br><span class="line"><span class="comment">// 准备update</span></span><br><span class="line">        update.<span class="property">eagerReducer</span> = lastRenderedReducer;</span><br><span class="line">        update.<span class="property">eagerState</span> = eagerState;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;<span class="comment">// Suppress the error. It will throw again in the render phase.</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title class_">ReactCurrentDispatcher</span>$<span class="number">1.</span>current = prevDispatcher;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 执行调度更新</span></span><br><span class="line">    <span class="title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>action</code>是用户传入的函数，以下是<code>lastRenderReducer</code>源码，所以函数内部可以获取之前的state</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">basicStateReducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="comment">// $FlowFixMe: Flow doesn&#x27;t like mixed types</span></span><br><span class="line">  <span class="comment">// 如果是函数，就传入之前state并调用，否则直接使用新的state</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span> ? <span class="title function_">action</span>(state) : action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useEffect源码</span></span><br><span class="line"><span class="attr">useEffect</span>: <span class="keyword">function</span> (<span class="params">create, deps</span>) &#123;</span><br><span class="line">    currentHookNameInDev = <span class="string">&#x27;useEffect&#x27;</span>;</span><br><span class="line">    <span class="title function_">mountHookTypesDev</span>(); <span class="comment">// 添加 hookName 到 hookTpyeDev</span></span><br><span class="line">    <span class="title function_">checkDepsAreArrayDev</span>(deps); <span class="comment">// 检查useEffect的deps格式是否为数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mountEffect</span>(create, deps); <span class="comment">// useEffect的主要逻辑</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li><code>mountEffect</code>检查一下<code>jest</code>会调用下面这个函数，执行逻辑</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>) &#123;</span><br><span class="line">    <span class="comment">// create就是用户订阅的effect函数</span></span><br><span class="line">    <span class="keyword">var</span> hook = <span class="title function_">mountWorkInProgressHook</span>(); <span class="comment">// 生成hook对象</span></span><br><span class="line">    <span class="keyword">var</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">    currentlyRenderingFiber$<span class="number">1.</span>flags |= fiberFlags;</span><br><span class="line">    hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>(<span class="title class_">HasEffect</span> | hookFlags, create, <span class="literal">undefined</span>, nextDeps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>hook</code>的<code>memoizedState</code>不同于<code>useState</code>，<code>useEffect</code>会记录当前的<code>create</code>函数、<code>deps</code>依赖数据和调用顺序</li></ul><h3 id="commitRoot"><a href="#commitRoot" class="headerlink" title="commitRoot"></a>commitRoot</h3><ul><li><code>commitRoot</code>在执行挂载真正DOM树的操作之前还会执行一个额外的程序</li></ul><blockquote><p>invokeGuardedCallback(null, commitBeforeMutationEffects, null);</p></blockquote><ul><li><p><strong><code>invokeGuardedCallback</code>是React中用于<code>DEV</code>环境下触发事件的，附带有各种错误捕获和消息提示</strong></p></li><li><p>在经过一系列我看不懂的调用之后，会执行<code>flushPassiveEffects</code>函数，在这个函数内部会执行用户定义的<code>effect函数</code></p></li></ul><p>此时的调用栈</p><img src="/2022/03/27/ReactSourceHookDebug/44.png" class="" title="调用栈"><h3 id="commitBeforeMutationEffects"><a href="#commitBeforeMutationEffects" class="headerlink" title="commitBeforeMutationEffects"></a>commitBeforeMutationEffects</h3><ul><li>经过测试后，debug操作不同，下面<code>flushPassiveEffects</code>函数调用时机不同，这里看得很迷（应该是不懂React详细更新算法和逻辑的问题）<ul><li>单步进入，<code>flushPassiveEffects</code>函数会在<code>commitBeforeMutationEffects</code>函数中直接执行</li><li>单步跳过<code>commitBeforeMutationEffects</code>，会在React渲染完成之后单独执行</li></ul></li></ul><h4 id="flushPassiveEffects"><a href="#flushPassiveEffects" class="headerlink" title="flushPassiveEffects"></a>flushPassiveEffects</h4><ul><li>省略了其他代码（例如：这里还处理了<code>unMountEffects</code>，只不过没有执行）</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mountEffects = pendingPassiveHookEffectsMount; <span class="comment">// 这里是收集到的effects，并且实在mount阶段执行的effects</span></span><br><span class="line">pendingPassiveHookEffectsMount = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt; mountEffects.<span class="property">length</span>; _i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// effects数组每两个一组，前一个是effects，后一个是当前effects对应的fiber</span></span><br><span class="line">    <span class="keyword">var</span> _effect2 = mountEffects[_i];</span><br><span class="line">    <span class="keyword">var</span> _fiber = mountEffects[_i + <span class="number">1</span>];</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">setCurrentFiber</span>(_fiber); <span class="comment">// 设置当前环境fiber</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用invokePassiveEffectCreate执行effects函数</span></span><br><span class="line">            <span class="title function_">invokeGuardedCallback</span>(<span class="literal">null</span>, invokePassiveEffectCreate, <span class="literal">null</span>, _effect2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">hasCaughtError</span>()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">resetCurrentFiber</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数最后还会调用下面这个函数，这样会去清除<code>syncQueue</code>队列内部的更新事件，这也是为什么如果在<code>useEffect</code>中设置<code>state</code>会导致无限更新的原因</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">flushSyncCallbackQueue</span>(); </span><br><span class="line"><span class="comment">// 这个函数内部会调用flushSyncCallbackQueue()</span></span><br></pre></td></tr></table></figure><h4 id="invokePassiveEffectCreate"><a href="#invokePassiveEffectCreate" class="headerlink" title="invokePassiveEffectCreate"></a>invokePassiveEffectCreate</h4><ul><li>真正执行<code>effects</code>函数的代码</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invokePassiveEffectCreate</span>(<span class="params">effect</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> create = effect.<span class="property">create</span>;</span><br><span class="line">    effect.<span class="property">destroy</span> = <span class="title function_">create</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// effects如下</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="number">5</span>, <span class="comment">// 标识hook类型</span></span><br><span class="line">  <span class="attr">create</span>: <span class="function">() =&gt;</span> &#123; <span class="comment">// 这个就是用户的effect函数</span></span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;effect!&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">destroy</span>: <span class="literal">undefined</span>, <span class="comment">// 存储可能存在的销毁函数</span></span><br><span class="line">  <span class="attr">deps</span>: <span class="literal">null</span>, <span class="comment">// 依赖数组</span></span><br><span class="line">  <span class="attr">next</span>: [<span class="title class_">Circular</span>], <span class="comment">// 下一个effect</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commitMutationEffects"><a href="#commitMutationEffects" class="headerlink" title="commitMutationEffects"></a>commitMutationEffects</h3><ul><li><strong>之前说过，React在这个函数中把Fiber树对应渲染好的真实DOM树添加到页面上，除此之外还会执行一次特定<code>effects</code></strong></li></ul><h4 id="commitHookEffectListUnmount"><a href="#commitHookEffectListUnmount" class="headerlink" title="commitHookEffectListUnmount"></a>commitHookEffectListUnmount</h4><ul><li><strong>执行所有<code>effects</code>的销毁函数，因为组件进行了一次更新</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分源码</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((effect.<span class="property">tag</span> &amp; tag) === tag) &#123;</span><br><span class="line">        <span class="comment">// Unmount</span></span><br><span class="line">        <span class="keyword">var</span> destroy = effect.<span class="property">destroy</span>; <span class="comment">// effect 对象</span></span><br><span class="line">        effect.<span class="property">destroy</span> = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">if</span> (destroy !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="title function_">destroy</span>(); <span class="comment">// 这个就是销毁函数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      effect = effect.<span class="property">next</span>; <span class="comment">// 执行下一个effect</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br></pre></td></tr></table></figure><h3 id="commitLayoutEffects"><a href="#commitLayoutEffects" class="headerlink" title="commitLayoutEffects"></a>commitLayoutEffects</h3><ul><li>在真实DOM渲染完成之后类似方式调用的函数</li></ul><blockquote><p>invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);</p></blockquote><h4 id="commitLifeCycles"><a href="#commitLifeCycles" class="headerlink" title="commitLifeCycles"></a>commitLifeCycles</h4><ul><li><p>如同函数名称一样，会处理各种生命周期函数（包括：effects）</p></li><li><p><code>commitHookEffectListMount</code>函数在满足某种条件下（没看懂…），执行<code>effect</code>函数</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分源码</span></span><br><span class="line"><span class="keyword">if</span> ((effect.<span class="property">tag</span> &amp; tag) === tag) &#123;</span><br><span class="line">    <span class="comment">// Mount</span></span><br><span class="line">    <span class="keyword">var</span> create = effect.<span class="property">create</span>;</span><br><span class="line">    effect.<span class="property">destroy</span> = <span class="title function_">create</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> destroy = effect.<span class="property">destroy</span>;</span><br><span class="line">        <span class="keyword">if</span> (destroy !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> destroy !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// ... 很多对返回的destroy函数使用不当的warn</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="schedulePassiveEffects"><a href="#schedulePassiveEffects" class="headerlink" title="schedulePassiveEffects"></a>schedulePassiveEffects</h4><ul><li><code>schedulePassiveEffects</code>函数会将需要执行的<code>effect</code>保存下来，在后续调用？</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分源码</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> _effect = effect,</span><br><span class="line">        next = _effect.<span class="property">next</span>,</span><br><span class="line">        tag = _effect.<span class="property">tag</span>;</span><br><span class="line">    <span class="keyword">if</span> ((tag &amp; <span class="title class_">Passive</span>$<span class="number">1</span>) !== <span class="title class_">NoFlags</span>$<span class="number">1</span> &amp;&amp; (tag &amp; <span class="title class_">HasEffect</span>) !== <span class="title class_">NoFlags</span>$<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 下面两个函数分别将fiber和hook存入pendingPassiveHookEffectsUnmount和pendingPassiveHookEffectsMount</span></span><br><span class="line">        <span class="comment">// 而pendingPassiveHookEffectsMount就是在flushPassiveEffects函数中获取effect的数组</span></span><br><span class="line">        <span class="title function_">enqueuePendingPassiveHookEffectUnmount</span>(finishedWork, effect);</span><br><span class="line">        <span class="title function_">enqueuePendingPassiveHookEffectMount</span>(finishedWork, effect);</span><br><span class="line">    &#125;</span><br><span class="line">    effect = next;</span><br><span class="line">&#125; <span class="keyword">while</span> (effect !== firstEffect);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> source </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactSourceDebug</title>
      <link href="/2022/03/21/ReactSourceDebug/"/>
      <url>/2022/03/21/ReactSourceDebug/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>React源码版本：<code>17.0.2</code></li><li>Debug Demo 如下：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;<span class="built_in">any</span>, &#123; <span class="attr">text</span>: <span class="built_in">string</span> &#125;&gt; &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">text</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;this.state.text&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>normal<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            debugger;</span></span><br><span class="line"><span class="language-xml">            this.setState(&#123; text: &quot;check&quot; &#125;);</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">          setState</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Test</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>根据DEMO，本次学习仅针对React在Web层的渲染<ul><li>页面的初始渲染</li><li>点击按钮后的一次更新渲染</li></ul></li><li>辅助学习文章——<a href="https://www.zhihu.com/people/lam-14-21-74">Lam大佬的React源码解析文章</a></li><li><strong>本文仅是学习记录，记录一些源码的理解，并非详细分析源码</strong></li></ul><h2 id="初次渲染"><a href="#初次渲染" class="headerlink" title="初次渲染"></a>初次渲染</h2><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Test</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>通过传入入口组件（通常是<code>&lt;App /&gt;</code>）进行整体页面的渲染</li></ul><h3 id="JSX处理"><a href="#JSX处理" class="headerlink" title="JSX处理"></a>JSX处理</h3><ul><li>注意下<code>webpack</code>对所有的JSX进行了处理，比如入口代打包成了这样</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">react_dom__WEBPACK_IMPORTED_MODULE_1__.<span class="title function_">render</span>( <span class="comment">/*#__PURE__*/</span>(<span class="number">0</span>,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.<span class="property">jsxDEV</span>)(<span class="title class_">Test</span>, &#123;&#125;, <span class="built_in">void</span> <span class="number">0</span>, <span class="literal">false</span>, &#123;</span><br><span class="line">  <span class="attr">fileName</span>: _jsxFileName,</span><br><span class="line">  <span class="attr">lineNumber</span>: <span class="number">52</span>,</span><br><span class="line">  <span class="attr">columnNumber</span>: <span class="number">17</span></span><br><span class="line">&#125;, <span class="literal">undefined</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>可以看到所有的JSX都包裹在了一个函数中，函数中有两个关键动作<ul><li>对JSX写法进行验证，是否符合语法</li><li>对JSX进行解析</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DEMO中的Test解析返回的结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">$$typeof</span>: <span class="title class_">Symbol</span>(react.<span class="property">element</span>),</span><br><span class="line">  <span class="attr">type</span>: <span class="keyword">class</span> <span class="title class_">Test</span> <span class="comment">/* 这里省略Test的结构 */</span>,</span><br><span class="line">  <span class="attr">key</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">ref</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">_owner</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">_store</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><ul><li>首次渲染时会去创建<code>root</code>，同时代码首次涉及到React16加入的<code>Fiber</code>数据结构</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建FiberRoot的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createFiberRoot</span>(<span class="params">containerInfo, tag, hydrate, hydrationCallbacks</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> root = <span class="keyword">new</span> <span class="title class_">FiberRootNode</span>(containerInfo, tag, hydrate);</span><br><span class="line">  <span class="keyword">var</span> uninitializedFiber = <span class="title function_">createHostRootFiber</span>(tag);</span><br><span class="line">  root.<span class="property">current</span> = uninitializedFiber;</span><br><span class="line">  uninitializedFiber.<span class="property">stateNode</span> = root;</span><br><span class="line">  <span class="title function_">initializeUpdateQueue</span>(uninitializedFiber);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上此时的调用栈</p><img src="/2022/03/21/ReactSourceDebug/3.png" class="" title="调用栈"><h4 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h4><ul><li>源码整体Debug下来，每一个Fiber对应<code>JSX</code>的每一个节点（不同于真实DOM树），Fiber树包括了<code>&lt;App /&gt;</code>这样的组件</li><li>React整体基于Fiber树进行更新，可以说Fiber树就是React的虚拟DOM</li><li>Fiber树的结构如下，以DEMO为例：</li></ul><img src="/2022/03/21/ReactSourceDebug/1.png" class="" title="Fiber树结构"><ul><li><p><strong>每个Fiber只有一个父节点、一个子节点、一个兄弟节点</strong>，可能没有父节点（root），可能没有子节点（两个span和button）、可能没有兄弟节点，但有也不会超过一个</p><ul><li>所以Fiber有以下的数据结构：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fiber</span> &#123;</span><br><span class="line">    <span class="attr">return</span>:<span class="title class_">FiberNode</span>, <span class="comment">//父节点</span></span><br><span class="line">    <span class="attr">sibiling</span>:<span class="title class_">FiberNode</span>, <span class="comment">//兄弟节点</span></span><br><span class="line">    <span class="attr">child</span>:<span class="title class_">FiberNode</span>, <span class="comment">//子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Fiber节点上记录了对应节点的所有需要渲染的属性，例如：rootFiber有下面这些属性（<strong>某些属性是rootFiber独有的</strong>）：</p></li></ul><img src="/2022/03/21/ReactSourceDebug/2.png" class="" title="Fiber属性"><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><ul><li>React会在root节点上监听所有可能的事件</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建rootFiber之后，调用的监听函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listenToAllSupportedEvents</span>(<span class="params">rootContainerElement</span>) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (rootContainerElement[listeningMarker]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rootContainerElement[listeningMarker] = <span class="literal">true</span>;</span><br><span class="line">    allNativeEvents.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">domEventName</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!nonDelegatedEvents.<span class="title function_">has</span>(domEventName)) &#123;</span><br><span class="line">        <span class="title function_">listenToNativeEvent</span>(domEventName, <span class="literal">false</span>, rootContainerElement, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">listenToNativeEvent</span>(domEventName, <span class="literal">true</span>, rootContainerElement, <span class="literal">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>allNativeEvents</code>包含了React预定的所有事件，React将事件分成了三组，分为三种优先级，例如优先级最低的一组为：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> discreteEventPairsForSimpleEventPlugin = [<span class="string">&#x27;cancel&#x27;</span>, <span class="string">&#x27;cancel&#x27;</span>, <span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;close&#x27;</span>, <span class="string">&#x27;close&#x27;</span>,<span class="comment">/*...其余好多事件*/</span>];</span><br></pre></td></tr></table></figure><ul><li>在<code>root</code>上监听事件之后，所有事件都会在<code>root</code>上触发对应处理函数，并后续调用<code>dispatchEvent</code>函数，<strong>这个函数会统一调度和处理所有事件，并在最后进行更新</strong></li></ul><h3 id="updateContainer"><a href="#updateContainer" class="headerlink" title="updateContainer"></a>updateContainer</h3><ul><li>更新（处理Fiber）函数<ul><li><code>unbatchedUpdates</code>涉及到了React的合成事件系统（没有详细了解…）</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">unbatchedUpdates</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>函数内部对React的更新算法进行了初始化<ul><li><code>updatequeue</code></li><li><code>lane</code>算法</li></ul></li></ul><h3 id="workLoopSync"><a href="#workLoopSync" class="headerlink" title="workLoopSync"></a>workLoopSync</h3><ul><li>此函数对Fiber树进行遍历，同时<strong>创建和处理</strong>所有的Fiber节点</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopSync</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Already timed out, so perform work without checking if we need to yield.</span></span><br><span class="line">    <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的调用栈：</p><img src="/2022/03/21/ReactSourceDebug/4.png" class="" title="调用栈"><h3 id="Fiber遍历"><a href="#Fiber遍历" class="headerlink" title="Fiber遍历"></a>Fiber遍历</h3><ul><li><p><code>workLoopSync</code>对<strong>Fiber树的遍历（此时其实还只有一个rootFiber根）</strong>主要调用了两个函数</p><ul><li><code>beginWork</code></li><li><code>completeUnitOfWork</code></li></ul></li><li><p>这两个函数都会根据Fiber节点的不同，进行不同的处理</p><ul><li><strong><code>beginWork</code>函数会对每一种Fiber节点调用<code>reconcileChildren</code>函数，通过传入Fiber的child（这里的child是通过JSX解析获取的，还不是Fiber）创建对应的Fiber并且返回这个Fiber</strong></li><li><strong><code>completeUnitOfWork</code>函数则会根据Fiber的类型真正创建DOM节点，并对其初始化</strong></li></ul></li><li><p>同时在<code>workLoopSync</code>内部会按照下面的顺序进行遍历（<strong>b代表<code>beginWork</code>，b1代表第一步调用<code>beginWork</code>处理对应节点</strong>）：<img src="/2022/03/21/ReactSourceDebug/5.png" class="" title="更新顺序"></p></li><li><p>可以看出，Fiber树遍历之后，<code>workLoopSync</code>会返回Fiber树的根节点，也就是<code>root</code>节点</p></li></ul><h3 id="commitRoot"><a href="#commitRoot" class="headerlink" title="commitRoot"></a>commitRoot</h3><ul><li><code>commitRoot</code>函数则会真正将Fiber树对应的真实DOM结构渲染到页面上</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commitRoot函数内部调用渲染真实DOM的部分代码</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">invokeGuardedCallback</span>(<span class="literal">null</span>, commitMutationEffects, <span class="literal">null</span>, root, renderPriorityLevel);</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">hasCaughtError</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(nextEffect !== <span class="literal">null</span>)) &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="title class_">Error</span>( <span class="string">&quot;Should be working on an effect.&quot;</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> _error = <span class="title function_">clearCaughtError</span>();</span><br><span class="line">            <span class="title function_">captureCommitPhaseError</span>(nextEffect, _error);</span><br><span class="line">            nextEffect = nextEffect.<span class="property">nextEffect</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><ul><li>代码中还执行了另外两次相似函数，分别在上述代码前后执行<ul><li><code>invokeGuardedCallback(null, commitBeforeMutationEffects, null);</code></li><li><code>invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);</code></li></ul></li></ul><p>此时的调用栈：<img src="/2022/03/21/ReactSourceDebug/6.png" class="" title="调用栈"></p><ul><li>在上述代码执行过后，页面上才会真正渲染出真实DOM</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Javascript </tag>
            
            <tag> source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RustStudyBasic</title>
      <link href="/2022/02/22/RustStudyBasic/"/>
      <url>/2022/02/22/RustStudyBasic/</url>
      
        <content type="html"><![CDATA[<h2 id="Rust基础学习总结"><a href="#Rust基础学习总结" class="headerlink" title="Rust基础学习总结"></a>Rust基础学习总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>之前浏览公众号的时候看见几篇文章，谈及Rust对前端基础建设具有可观的潜力<del>（同时在家里有点无聊）</del>，自己也对这方面感兴趣，就从 2.9 开始学习Rust<ul><li>学习方式：阅读<a href="https://kaisery.github.io/trpl-zh-cn/title-page.html">Rust 程序设计语言</a> + 手动练习语法</li></ul></li><li>2.22 阅读完前19章（除了最后的练习项目以及附录），下文则是<strong>简单的学习总结</strong><ul><li>由于之前一直在学习和使用**<code>JavaScript</code>**（下文写作JS），所以也使用JS中的语法做比较</li></ul></li></ul><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello_world"></a>hello_world</h2><h3 id="编程习惯"><a href="#编程习惯" class="headerlink" title="编程习惯"></a>编程习惯</h3><ul><li>Rust对变量、文件、函数等命名规定使用<code>_</code>分割单词，例如：<code>hello_world.rs</code>，JS没有明说，但大部分人使用驼峰命名，例如：<code>helloWorld.js</code></li></ul><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><ul><li>JS不用多说，浏览器是一切的开始（具体可以是chrome的V8引擎），Rust需要从官网安装运行环境，同时自带官方包管理器（Cargo），类比Node和npm</li></ul><h3 id="语言特征"><a href="#语言特征" class="headerlink" title="语言特征"></a>语言特征</h3><ul><li>Rust和原生JS相反，Rust是静态语言，需要先编译再运行，同时也需要指明类型供编译器检查</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>大多数编程语言公有的类型，Rust也一样，这些可以略过</p><ul><li>数据类型</li><li>函数</li><li>结构（类比class）</li><li>枚举</li><li>控制流（Rust的控制流可以玩得比较花）</li><li>泛型（静态语言一般都有）</li><li>迭代器</li><li>…</li></ul></li><li><p>Rust最为独特的特性无疑是**<code>ownership</code>**（所有权系统）</p></li></ul><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><ul><li>Rust对比JS更偏向于底层，JS的垃圾回收自动执行，Rust也是自动执行，但是是基于所有权系统执行</li><li>所有权系统也保证了Rust的内存安全</li><li>官方给出的所有权规则</li></ul><blockquote><ul><li>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量。</li><li>值在任一时刻有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。</li></ul></blockquote><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li>学到这里的第一反应就是C++中的引用（keyword都一样<code>&amp;</code>）</li><li>Rust的引用实际上也是在所有权系统之上运行</li><li>官方给出的引用规则</li></ul><blockquote><ul><li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li><li>引用必须总是有效的。</li></ul></blockquote><ul><li>理解引用十分重要，后续Rust代码编写过程中，会处处使用到引用。在我学习过程中，基本可以理解引用为指针（官方也这么类比），一般引用可以是C语言中的**<code>* const ptr</code>**（值不可变）</li></ul><h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><ul><li>Rust有官方的包管理器，模块系统也有自己的一套，不过模块系统实际要解决的问题和其他语言一样，所以容易理解，只是关键字需要替换下</li></ul><h2 id="trait和life-cycle"><a href="#trait和life-cycle" class="headerlink" title="trait和life_cycle"></a>trait和life_cycle</h2><h3 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h3><ul><li>学习到这里让我想到了红宝书（JavaScript）中讲到<code>class</code>提及的组合模式以及设计模式中经典的鸭子类型</li><li>简而言之，可以为<code>struct</code>实现<code>trait</code>，那么就可以调用<code>trait</code>中的方法（不会关心是什么类型的<code>struct</code>）</li><li>学习完基础的<code>trait</code>，可以发现Rust到处都是用到了<code>trait</code>，最常用到的打印宏<code>println!</code>，里面需要格式化输出时，可以输出的数据类型，都在Rust内部实现了**<code>std::fmt::Display</code>**，例如：String、i8-128、u8-128、Vec等</li></ul><h3 id="life-cycle"><a href="#life-cycle" class="headerlink" title="life_cycle"></a>life_cycle</h3><ul><li>还是由于所有权系统引出的引用所需要的语法，Rust确保不会出现空指针（NULL）（unsafe情况下可能出现），所以函数传入引用参数，返回引用时Rust编译器检查会出问题，可能会出现悬垂引用（类比空指针），Rust为了不让这种情况出现，需要我们指明引用关系（声明周期）</li><li>读完文档之后，很好理解，除了语法很怪（<code>fn test&lt;&#39;a&gt;(str1:&amp;&#39;a str)-&gt;&amp;&#39;a str</code>）</li></ul><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul><li><p>和C语言的指针基本一致，学习下来智能最大体现在不需要手动释放（例如：<code>free(p);</code>）</p></li><li><p>同时也涉及到了解引用（和C语言一样的keyword：<code>*</code>），Rust内部则是使用**<code>trait</code><strong>实现，实际上Rust可以使用</strong><code>trait</code>**实现运算符重载</p><ul><li>效果和C语言一致，解引用可以读写指针指向的内存地址上存放的值</li></ul></li><li><p>后续涉及到了引用计数<code>RC&lt;&gt;</code>（很像JS的过去的垃圾回收机制，但是Rust是为了实现多个所有权的特殊情况），内部不可变性<code>RefCell&lt;&gt;</code></p></li></ul><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul><li>JS很熟悉的一个概念，我的简单理解就是：<strong>函数可以随便传</strong>（例如：函数当做参数传递给函数）</li><li>Rust也一样，可以利用泛型和<code>trait</code>配合，把函数当做参数传递给函数，实现许多高阶功能</li><li>同时Rust还有闭包（JS中的闭包更偏向于变量机制），Rust主要是可以实现内联匿名函数，写出许多灵活的代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2SourceDebug</title>
      <link href="/2021/11/15/vue2SourceDebug/"/>
      <url>/2021/11/15/vue2SourceDebug/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前了解Vue源码都是通过网上一些文章获取，从未真正debug过Vue源码，所以就有了这篇文章</p><p><strong>写完之后发现就是源码的堆积，理解还是不够啊</strong></p><ul><li>Vue版本：2.6.14</li><li>简单手动配置webpack后进行debug</li><li>入口文件代码如下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* index.js */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Header</span> <span class="keyword">from</span> <span class="string">&quot;./components/Header/index.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">debugger</span>; <span class="comment">//此处进行debug调试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123; <span class="comment">// 测试data</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">text</span>: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">      <span class="attr">ifFlag</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">inputValue</span>: <span class="string">&quot;input something&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123; <span class="comment">// 测试methods</span></span><br><span class="line">    <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==app hello&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123; <span class="comment">// 测试computed</span></span><br><span class="line">    <span class="title function_">reversedText</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">text</span>.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 测试lifeCycle</span></span><br><span class="line">  <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==app before create&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==app created&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">beforeMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==app before mount&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==app mounted&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">beforeUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==app before update&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">updated</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==app updated&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 测试component</span></span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">Header</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 测试template</span></span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div id=&quot;app&quot; @click=&quot;hello&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;&#123;&#123;reversedText&#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-if=&quot;ifFlag&quot;&gt;ifFlag is true then I will show&lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;input v-model=&quot;inputValue&quot; /&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;what you input is:&#123;&#123;inputValue&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;Header :propValue=&quot;&#x27;from app&#x27;&quot; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Header组件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Header.js */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;Header&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div @click=&quot;showMsg&quot; class=&quot;header&quot;&gt;</span></span><br><span class="line"><span class="string">    text:&#123;&#123;text&#125;&#125;</span></span><br><span class="line"><span class="string">    propValue:&#123;&#123;propValue&#125;&#125;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">text</span>: <span class="string">&quot;i am header&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&quot;propValue&quot;</span>], <span class="comment">// props测试</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">showMsg</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==from header&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==Header components created&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==Header components mounted&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Vue2源码的一次debug"><a href="#Vue2源码的一次debug" class="headerlink" title="Vue2源码的一次debug"></a>Vue2源码的一次debug</h2><p><strong>debug过程中，相关源码会进行简化，省略无关代码（例如所有环境分支均已删除，保留开发环境）</strong></p><p>单步调试<code>export default new Vue(&#123;...&#125;)</code>，就会进入Vue的构造函数内部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (options) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到Vue的构造函数很简单，接受传入的options，直接调用<code>_init</code>方法初始化</li></ul><h3 id="init"><a href="#init" class="headerlink" title="__init"></a>__init</h3><p>_init方法在源码中已被mixin（混入）Vue构造方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">    vm.<span class="property">_isVue</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// merge options</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponent</span>) &#123;</span><br><span class="line">        <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">        <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">        <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">        <span class="title function_">initInternalComponent</span>(vm, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">            <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">            options || &#123;&#125;,</span><br><span class="line">            vm</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm.<span class="property">_self</span> = vm;</span><br><span class="line">    <span class="title function_">initLifecycle</span>(vm);</span><br><span class="line">    <span class="title function_">initEvents</span>(vm);</span><br><span class="line">    <span class="title function_">initRender</span>(vm);</span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">    <span class="title function_">initInjections</span>(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    <span class="title function_">initState</span>(vm);</span><br><span class="line">    <span class="title function_">initProvide</span>(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">        vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>初始化变量 vm &#x3D; 当前即将创建的Vue对象</li><li>标记当前即将创建的对象是Vue<code>_isVue = true</code></li><li><strong>可以关注下两个声明周期函数的执行时间</strong></li><li><strong>最后把Vue挂载到DOM上</strong></li><li><strong>下面是每个步骤函数的简单解析</strong></li></ul><h4 id="initInternalComponent"><a href="#initInternalComponent" class="headerlink" title="initInternalComponent"></a>initInternalComponent</h4><ul><li>Vnode中存在自定义组件时，在创建真实DOM元素的时候才会调用这个函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initInternalComponent</span> (vm, options) &#123;</span><br><span class="line">    <span class="keyword">var</span> opts = vm.<span class="property">$options</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(vm.<span class="property">constructor</span>.<span class="property">options</span>);</span><br><span class="line">    <span class="comment">// doing this because it&#x27;s faster than dynamic enumeration.</span></span><br><span class="line">    <span class="keyword">var</span> parentVnode = options.<span class="property">_parentVnode</span>;</span><br><span class="line">    opts.<span class="property">parent</span> = options.<span class="property">parent</span>;</span><br><span class="line">    opts.<span class="property">_parentVnode</span> = parentVnode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> vnodeComponentOptions = parentVnode.<span class="property">componentOptions</span>;</span><br><span class="line">    opts.<span class="property">propsData</span> = vnodeComponentOptions.<span class="property">propsData</span>;</span><br><span class="line">    opts.<span class="property">_parentListeners</span> = vnodeComponentOptions.<span class="property">listeners</span>;</span><br><span class="line">    opts.<span class="property">_renderChildren</span> = vnodeComponentOptions.<span class="property">children</span>;</span><br><span class="line">    opts.<span class="property">_componentTag</span> = vnodeComponentOptions.<span class="property">tag</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">render</span>) &#123;</span><br><span class="line">        opts.<span class="property">render</span> = options.<span class="property">render</span>;</span><br><span class="line">        opts.<span class="property">staticRenderFns</span> = options.<span class="property">staticRenderFns</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：<code>options.__parentVnode</code>指的是组件自身的VNode，<code>options.parentVnode</code>指的是父组件的Vue实例对象</li></ul><h4 id="mergeOptoins"><a href="#mergeOptoins" class="headerlink" title="mergeOptoins"></a>mergeOptoins</h4><ul><li><p>合并option（选项）</p></li><li><p>resolveConstructorOptions函数获取了<code>Vue.constructor</code>上的属性</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeOptions</span> (</span><br><span class="line">  parent, <span class="comment">// Vue.constructor上的属性</span></span><br><span class="line">  child, <span class="comment">// 我们传入的option</span></span><br><span class="line">  vm <span class="comment">// 当前Vue对象</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">checkComponents</span>(child);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">normalizeProps</span>(child, vm);</span><br><span class="line">  <span class="title function_">normalizeInject</span>(child, vm);</span><br><span class="line">  <span class="title function_">normalizeDirectives</span>(child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Apply extends and mixins on the child options,</span></span><br><span class="line">  <span class="comment">// but only if it is a raw options object that isn&#x27;t</span></span><br><span class="line">  <span class="comment">// the result of another mergeOptions call.</span></span><br><span class="line">  <span class="comment">// Only merged options has the _base property.</span></span><br><span class="line">  <span class="keyword">if</span> (!child.<span class="property">_base</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.<span class="property">extends</span>) &#123;</span><br><span class="line">      parent = <span class="title function_">mergeOptions</span>(parent, child.<span class="property">extends</span>, vm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child.<span class="property">mixins</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = child.<span class="property">mixins</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">        parent = <span class="title function_">mergeOptions</span>(parent, child.<span class="property">mixins</span>[i], vm);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> options = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> key;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    <span class="title function_">mergeField</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">hasOwn</span>(parent, key)) &#123;</span><br><span class="line">      <span class="title function_">mergeField</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">mergeField</span> (key) &#123;</span><br><span class="line">    <span class="keyword">var</span> strat = strats[key] || defaultStrat;</span><br><span class="line">    options[key] = <span class="title function_">strat</span>(parent[key], child[key], vm, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>checkComponents</code>函数检测<strong>自定义组件名是否规范</strong>（例如：不能自定义一个div组件，html已有div标签）</li><li><code>normalizeProps</code>函数检测**<code>props</code>是否规范**（例如：是否是array或者plainObject）<ul><li>同时也进行了格式化，连字符格式转为驼峰格式</li></ul></li><li>normalizeInject、normalizeDirectives函数同上</li><li>后续针对extends和mixins方法创建的子构造器合并了选项</li><li>最后合并父子的option选项，合并时的优先级如下：（<strong>优先级高的覆盖优先级低的，不会∪在一起</strong>）<ul><li>自定义option</li><li>子option</li><li>父option</li></ul></li></ul><h4 id="initProxy"><a href="#initProxy" class="headerlink" title="initProxy"></a>initProxy</h4><ul><li>仅用于开发环境，利用es6的proxy代理Vue属性的访问，当访问不存在的属性时，log提醒</li></ul><h4 id="initLifecycle"><a href="#initLifecycle" class="headerlink" title="initLifecycle"></a>initLifecycle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initLifecycle</span> (vm) &#123;</span><br><span class="line">  <span class="keyword">var</span> options = vm.<span class="property">$options</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// locate first non-abstract parent</span></span><br><span class="line">  <span class="keyword">var</span> parent = options.<span class="property">parent</span>;</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.<span class="property">abstract</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent.<span class="property">$options</span>.<span class="property">abstract</span> &amp;&amp; parent.<span class="property">$parent</span>) &#123;</span><br><span class="line">      parent = parent.<span class="property">$parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    parent.<span class="property">$children</span>.<span class="title function_">push</span>(vm);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm.<span class="property">$parent</span> = parent;</span><br><span class="line">  vm.<span class="property">$root</span> = parent ? parent.<span class="property">$root</span> : vm; <span class="comment">// 当前组件树的根 Vue 实例</span></span><br><span class="line"></span><br><span class="line">  vm.<span class="property">$children</span> = []; <span class="comment">// 当前实例的直接子组件</span></span><br><span class="line">  vm.<span class="property">$refs</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  vm.<span class="property">_watcher</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// lifeCycle的flag</span></span><br><span class="line">  vm.<span class="property">_inactive</span> = <span class="literal">null</span>;</span><br><span class="line">  vm.<span class="property">_directInactive</span> = <span class="literal">false</span>;</span><br><span class="line">  vm.<span class="property">_isMounted</span> = <span class="literal">false</span>;</span><br><span class="line">  vm.<span class="property">_isDestroyed</span> = <span class="literal">false</span>;</span><br><span class="line">  vm.<span class="property">_isBeingDestroyed</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先找到第一个非抽象父组件（keep-alive就是抽象组件）</li><li>初始化vm的一些属性</li></ul><h4 id="initEvents"><a href="#initEvents" class="headerlink" title="initEvents"></a>initEvents</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initEvents</span> (vm) &#123;</span><br><span class="line">  vm.<span class="property">_events</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  vm.<span class="property">_hasHookEvent</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// init parent attached events</span></span><br><span class="line">  <span class="keyword">var</span> listeners = vm.<span class="property">$options</span>.<span class="property">_parentListeners</span>;</span><br><span class="line">  <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">    <span class="title function_">updateComponentListeners</span>(vm, listeners);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化Vue对象的events（事件）功能，包括但不限于：<ul><li><strong>处理父组件传递的事件</strong></li><li><strong><code>this.$on</code>方法注册事件</strong></li><li><strong><code>this.$emit</code>方法触发事件</strong></li></ul></li></ul><h4 id="initRender"><a href="#initRender" class="headerlink" title="initRender"></a>initRender</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initRender</span> (vm) &#123;</span><br><span class="line">  vm.<span class="property">_vnode</span> = <span class="literal">null</span>; <span class="comment">// the root of the child tree</span></span><br><span class="line">  vm.<span class="property">_staticTrees</span> = <span class="literal">null</span>; <span class="comment">// v-once cached trees</span></span><br><span class="line">  <span class="keyword">var</span> options = vm.<span class="property">$options</span>;</span><br><span class="line">  <span class="keyword">var</span> parentVnode = vm.<span class="property">$vnode</span> = options.<span class="property">_parentVnode</span>; <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line">  <span class="keyword">var</span> renderContext = parentVnode &amp;&amp; parentVnode.<span class="property">context</span>;</span><br><span class="line">  vm.<span class="property">$slots</span> = <span class="title function_">resolveSlots</span>(options.<span class="property">_renderChildren</span>, renderContext);</span><br><span class="line">  vm.<span class="property">$scopedSlots</span> = emptyObject;</span><br><span class="line">  <span class="comment">// bind the createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line">  <span class="comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span></span><br><span class="line">  <span class="comment">// internal version is used by render functions compiled from templates</span></span><br><span class="line">  vm.<span class="property">_c</span> = <span class="keyword">function</span> (<span class="params">a, b, c, d</span>) &#123; <span class="keyword">return</span> <span class="title function_">createElement</span>(vm, a, b, c, d, <span class="literal">false</span>); &#125;;</span><br><span class="line">  <span class="comment">// normalization is always applied for the public version, used in</span></span><br><span class="line">  <span class="comment">// user-written render functions.</span></span><br><span class="line">  vm.<span class="property">$createElement</span> = <span class="keyword">function</span> (<span class="params">a, b, c, d</span>) &#123; <span class="keyword">return</span> <span class="title function_">createElement</span>(vm, a, b, c, d, <span class="literal">true</span>); &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $attrs &amp; $listeners are exposed for easier HOC creation.</span></span><br><span class="line">  <span class="comment">// they need to be reactive so that HOCs using them are always updated</span></span><br><span class="line">  <span class="keyword">var</span> parentData = parentVnode &amp;&amp; parentVnode.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="title function_">defineReactive$$1</span>(vm, <span class="string">&#x27;$attrs&#x27;</span>, parentData &amp;&amp; parentData.<span class="property">attrs</span> || emptyObject, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; <span class="title function_">warn</span>(<span class="string">&quot;$attrs is readonly.&quot;</span>, vm);</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">    <span class="title function_">defineReactive$$1</span>(vm, <span class="string">&#x27;$listeners&#x27;</span>, options.<span class="property">_parentListeners</span> || emptyObject, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      !isUpdatingChildComponent &amp;&amp; <span class="title function_">warn</span>(<span class="string">&quot;$listeners is readonly.&quot;</span>, vm);</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">defineReactive$$1</span>(vm, <span class="string">&#x27;$attrs&#x27;</span>, parentData &amp;&amp; parentData.<span class="property">attrs</span> || emptyObject, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="title function_">defineReactive$$1</span>(vm, <span class="string">&#x27;$listeners&#x27;</span>, options.<span class="property">_parentListeners</span> || emptyObject, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>初始化vm的一些属性</p><ul><li>_vnode指的是Vue对象挂载到DOM的VNode</li><li>$vnode指的是Vue组件在parent中template中的占位node</li></ul></li><li><p>resolveSlots函数解析组件传入的slot，并赋值给$slot</p><p>函数实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveSlots</span> (</span><br><span class="line">  children,</span><br><span class="line">  context</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!children || !children.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> slots = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = children.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> child = children[i];</span><br><span class="line">    <span class="keyword">var</span> data = child.<span class="property">data</span>;</span><br><span class="line">    <span class="comment">// remove slot attribute if the node is resolved as a Vue slot node</span></span><br><span class="line">    <span class="keyword">if</span> (data &amp;&amp; data.<span class="property">attrs</span> &amp;&amp; data.<span class="property">attrs</span>.<span class="property">slot</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> data.<span class="property">attrs</span>.<span class="property">slot</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// named slots should only be respected if the vnode was rendered in the</span></span><br><span class="line">    <span class="comment">// same context.</span></span><br><span class="line">    <span class="keyword">if</span> ((child.<span class="property">context</span> === context || child.<span class="property">fnContext</span> === context) &amp;&amp;</span><br><span class="line">      data &amp;&amp; data.<span class="property">slot</span> != <span class="literal">null</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">var</span> name = data.<span class="property">slot</span>;</span><br><span class="line">      <span class="keyword">var</span> slot = (slots[name] || (slots[name] = []));</span><br><span class="line">      <span class="keyword">if</span> (child.<span class="property">tag</span> === <span class="string">&#x27;template&#x27;</span>) &#123; <span class="comment">// 这里对template进行了特殊处理</span></span><br><span class="line">        slot.<span class="property">push</span>.<span class="title function_">apply</span>(slot, child.<span class="property">children</span> || []);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        slot.<span class="title function_">push</span>(child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      (slots.<span class="property">default</span> || (slots.<span class="property">default</span> = [])).<span class="title function_">push</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ignore slots that contains only whitespace</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> name$<span class="number">1</span> <span class="keyword">in</span> slots) &#123;</span><br><span class="line">    <span class="keyword">if</span> (slots[name$<span class="number">1</span>].<span class="title function_">every</span>(isWhitespace)) &#123;</span><br><span class="line">      <span class="keyword">delete</span> slots[name$<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slots</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同时创建了$createElement函数（_c函数同理），用于VDOM生成实际DOM</p></li><li><p>最后对<code>$attrs</code>和<code>$listeners</code>进行了响应式处理</p></li></ul><h4 id="callHook-‘beforeCreated’"><a href="#callHook-‘beforeCreated’" class="headerlink" title="callHook(‘beforeCreated’)"></a>callHook(‘beforeCreated’)</h4><p>顾名思义，此时调用了<code>beforeCreated</code>生命周期函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callHook</span> (vm, hook) &#123;</span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking lifecycle hooks</span></span><br><span class="line">  <span class="title function_">pushTarget</span>();</span><br><span class="line">  <span class="keyword">var</span> handlers = vm.<span class="property">$options</span>[hook];</span><br><span class="line">  <span class="keyword">var</span> info = hook + <span class="string">&quot; hook&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = handlers.<span class="property">length</span>; i &lt; j; i++) &#123;</span><br><span class="line">      <span class="title function_">invokeWithErrorHandling</span>(handlers[i], vm, <span class="literal">null</span>, vm, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">_hasHookEvent</span>) &#123;</span><br><span class="line">    vm.$emit(<span class="string">&#x27;hook:&#x27;</span> + hook);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">popTarget</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数头尾禁止了Dep的依赖收集</li><li><code>handlers</code>是一个数组，所以生命周期函数可以是多个</li><li><strong>invokeWithErrorHandling函数真正执行生命周期函数</strong></li></ul><h4 id="initInjections"><a href="#initInjections" class="headerlink" title="initInjections"></a>initInjections</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initInjections</span> (vm) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="title function_">resolveInject</span>(vm.<span class="property">$options</span>.<span class="property">inject</span>, vm);</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(result).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">defineReactive$$1</span>(vm, key, result[key], <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">&quot;Avoid mutating an injected value directly since the changes will be &quot;</span> +</span><br><span class="line">            <span class="string">&quot;overwritten whenever the provided component re-renders. &quot;</span> +</span><br><span class="line">            <span class="string">&quot;injection being mutated: \&quot;&quot;</span> + key + <span class="string">&quot;\&quot;&quot;</span>,</span><br><span class="line">            vm</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive$$1</span>(vm, key, result[key]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先找到是谁provide的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveInject</span> (inject, vm) &#123;</span><br><span class="line">  <span class="keyword">if</span> (inject) &#123;</span><br><span class="line">    <span class="comment">// inject is :any because flow is not smart enough to figure out cached</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">var</span> keys = hasSymbol</span><br><span class="line">      ? <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(inject)</span><br><span class="line">      : <span class="title class_">Object</span>.<span class="title function_">keys</span>(inject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> key = keys[i];</span><br><span class="line">      <span class="comment">// #6574 in case the inject object is observed...</span></span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;__ob__&#x27;</span>) &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">      <span class="keyword">var</span> provideKey = inject[key].<span class="property">from</span>;</span><br><span class="line">      <span class="keyword">var</span> source = vm;</span><br><span class="line">      <span class="keyword">while</span> (source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.<span class="property">_provided</span> &amp;&amp; <span class="title function_">hasOwn</span>(source.<span class="property">_provided</span>, provideKey)) &#123;</span><br><span class="line">          result[key] = source.<span class="property">_provided</span>[provideKey];</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        source = source.<span class="property">$parent</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;default&#x27;</span> <span class="keyword">in</span> inject[key]) &#123;</span><br><span class="line">          <span class="keyword">var</span> provideDefault = inject[key].<span class="property">default</span>;</span><br><span class="line">          result[key] = <span class="keyword">typeof</span> provideDefault === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">            ? provideDefault.<span class="title function_">call</span>(vm)</span><br><span class="line">            : provideDefault;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          <span class="title function_">warn</span>((<span class="string">&quot;Injection \&quot;&quot;</span> + key + <span class="string">&quot;\&quot; not found&quot;</span>), vm);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>找到所有inject的key值，然后遍历父组件找到对应的provide，获取表达式（值）</li></ul></li><li><p><strong>然后对获取的inject值进行响应式处理（defineReactive$$1）</strong></p></li></ul><h4 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initState</span> (vm) &#123;</span><br><span class="line">  vm.<span class="property">_watchers</span> = [];</span><br><span class="line">  <span class="keyword">var</span> opts = vm.<span class="property">$options</span>;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) &#123; <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) &#123; <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="title function_">initData</span>(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">observe</span>(vm.<span class="property">_data</span> = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) &#123; <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) &#123;</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>initState函数中初始化了我们在option中常用的功能<ul><li>父组件传值：props</li><li>方法：methods</li><li>数据：data</li><li>计算属性：computed</li><li>侦听器：watch</li></ul></li></ul><h5 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initProps</span> (vm, propsOptions) &#123;</span><br><span class="line">  <span class="keyword">var</span> propsData = vm.<span class="property">$options</span>.<span class="property">propsData</span> || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> props = vm.<span class="property">_props</span> = &#123;&#125;;</span><br><span class="line">  <span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line">  <span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line">  <span class="keyword">var</span> keys = vm.<span class="property">$options</span>.<span class="property">_propKeys</span> = [];</span><br><span class="line">  <span class="keyword">var</span> isRoot = !vm.<span class="property">$parent</span>;</span><br><span class="line">  <span class="comment">// root instance props should be converted</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> loop = <span class="keyword">function</span> (<span class="params"> key </span>) &#123;</span><br><span class="line">    keys.<span class="title function_">push</span>(key);</span><br><span class="line">    <span class="keyword">var</span> value = <span class="title function_">validateProp</span>(key, propsOptions, propsData, vm);</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> hyphenatedKey = <span class="title function_">hyphenate</span>(key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isReservedAttribute</span>(hyphenatedKey) ||</span><br><span class="line">          config.<span class="title function_">isReservedAttr</span>(hyphenatedKey)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          (<span class="string">&quot;\&quot;&quot;</span> + hyphenatedKey + <span class="string">&quot;\&quot; is a reserved attribute and cannot be used as component prop.&quot;</span>),</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">defineReactive$$1</span>(props, key, value, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(</span><br><span class="line">            <span class="string">&quot;Avoid mutating a prop directly since the value will be &quot;</span> +</span><br><span class="line">            <span class="string">&quot;overwritten whenever the parent component re-renders. &quot;</span> +</span><br><span class="line">            <span class="string">&quot;Instead, use a data or computed property based on the prop&#x27;s &quot;</span> +</span><br><span class="line">            <span class="string">&quot;value. Prop being mutated: \&quot;&quot;</span> + key + <span class="string">&quot;\&quot;&quot;</span>,</span><br><span class="line">            vm</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">defineReactive$$1</span>(props, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static props are already proxied on the component&#x27;s prototype</span></span><br><span class="line">    <span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line">    <span class="comment">// instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">&quot;_props&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> propsOptions) <span class="title function_">loop</span>( key );</span><br><span class="line">  <span class="title function_">toggleObserving</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>循环遍历props的值</p></li><li><p>validateProp函数检测props属性的值并做处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">validateProp</span> (</span><br><span class="line">  key,</span><br><span class="line">  propOptions,</span><br><span class="line">  propsData,</span><br><span class="line">  vm</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">var</span> prop = propOptions[key];</span><br><span class="line">  <span class="keyword">var</span> absent = !<span class="title function_">hasOwn</span>(propsData, key);</span><br><span class="line">  <span class="keyword">var</span> value = propsData[key];</span><br><span class="line">  <span class="comment">// boolean casting</span></span><br><span class="line">  <span class="keyword">var</span> booleanIndex = <span class="title function_">getTypeIndex</span>(<span class="title class_">Boolean</span>, prop.<span class="property">type</span>);</span><br><span class="line">  <span class="keyword">if</span> (booleanIndex &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (absent &amp;&amp; !<span class="title function_">hasOwn</span>(prop, <span class="string">&#x27;default&#x27;</span>)) &#123;</span><br><span class="line">      value = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === <span class="string">&#x27;&#x27;</span> || value === <span class="title function_">hyphenate</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// only cast empty string / same name to boolean if</span></span><br><span class="line">      <span class="comment">// boolean has higher priority</span></span><br><span class="line">      <span class="keyword">var</span> stringIndex = <span class="title function_">getTypeIndex</span>(<span class="title class_">String</span>, prop.<span class="property">type</span>);</span><br><span class="line">      <span class="keyword">if</span> (stringIndex &lt; <span class="number">0</span> || booleanIndex &lt; stringIndex) &#123;</span><br><span class="line">        value = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check default value</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    value = <span class="title function_">getPropDefaultValue</span>(vm, prop, key);</span><br><span class="line">    <span class="comment">// since the default value is a fresh copy,</span></span><br><span class="line">    <span class="comment">// make sure to observe it.</span></span><br><span class="line">    <span class="keyword">var</span> prevShouldObserve = shouldObserve;</span><br><span class="line">    <span class="title function_">toggleObserving</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="title function_">observe</span>(value);</span><br><span class="line">    <span class="title function_">toggleObserving</span>(prevShouldObserve);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// skip validation for weex recycle-list child component props</span></span><br><span class="line">    !(<span class="literal">false</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="title function_">assertProp</span>(prop, key, value, vm, absent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>根据props的type处理默认值</strong></li><li><strong>确保props的响应式</strong></li><li><strong>验证传入的props</strong></li></ul></li><li><p>最后进行一次响应式处理</p></li></ul><h5 id="initMethods"><a href="#initMethods" class="headerlink" title="initMethods"></a>initMethods</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initMethods</span> (vm, methods) &#123;</span><br><span class="line">  <span class="keyword">var</span> props = vm.<span class="property">$options</span>.<span class="property">props</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> methods[key] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&quot;Method \&quot;&quot;</span> + key + <span class="string">&quot;\&quot; has type \&quot;&quot;</span> + (<span class="keyword">typeof</span> methods[key]) + <span class="string">&quot;\&quot; in the component definition. &quot;</span> +</span><br><span class="line">          <span class="string">&quot;Did you reference the function correctly?&quot;</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          (<span class="string">&quot;Method \&quot;&quot;</span> + key + <span class="string">&quot;\&quot; has already been defined as a prop.&quot;</span>),</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((key <span class="keyword">in</span> vm) &amp;&amp; <span class="title function_">isReserved</span>(key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&quot;Method \&quot;&quot;</span> + key + <span class="string">&quot;\&quot; conflicts with an existing Vue instance method. &quot;</span> +</span><br><span class="line">          <span class="string">&quot;Avoid defining component methods that start with _ or $.&quot;</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vm[key] = <span class="keyword">typeof</span> methods[key] !== <span class="string">&#x27;function&#x27;</span> ? noop : <span class="title function_">bind</span>(methods[key], vm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>做了写简单的验证，之后通过bind函数绑定this，然后挂载到vm（Vue实例）上</li></ul><h5 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span> (vm) &#123;</span><br><span class="line">  <span class="keyword">var</span> data = vm.<span class="property">$options</span>.<span class="property">data</span>;</span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? <span class="title function_">getData</span>(data, vm)</span><br><span class="line">    : data || &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isPlainObject</span>(data)) &#123;</span><br><span class="line">    data = &#123;&#125;;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">&#x27;data functions should return an object:\n&#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data);</span><br><span class="line">  <span class="keyword">var</span> props = vm.<span class="property">$options</span>.<span class="property">props</span>;</span><br><span class="line">  <span class="keyword">var</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span>;</span><br><span class="line">  <span class="keyword">var</span> i = keys.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          (<span class="string">&quot;Method \&quot;&quot;</span> + key + <span class="string">&quot;\&quot; has already been defined as a data property.&quot;</span>),</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&quot;The data property \&quot;&quot;</span> + key + <span class="string">&quot;\&quot; is already declared as a prop. &quot;</span> +</span><br><span class="line">        <span class="string">&quot;Use prop default value instead.&quot;</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">&quot;_data&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取data数据，如果是函数，通过getData函数获取里面的值</li><li>进行一些简单的验证<ul><li>方法重名、props重名、data函数没有返回plainObje</li></ul></li><li>proxy代理<code>_data</code>属性</li><li><strong>响应式处理data</strong></li></ul><h5 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initComputed</span> (vm, computed) &#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">var</span> watchers = vm.<span class="property">_computedWatchers</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">var</span> isSSR = <span class="title function_">isServerRendering</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">var</span> userDef = computed[key];</span><br><span class="line">    <span class="keyword">var</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.<span class="property">get</span>;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        (<span class="string">&quot;Getter is missing for computed property \&quot;&quot;</span> + key + <span class="string">&quot;\&quot;.&quot;</span>),</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="title function_">defineComputed</span>(vm, key, userDef);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.<span class="property">$data</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>((<span class="string">&quot;The computed property \&quot;&quot;</span> + key + <span class="string">&quot;\&quot; is already defined in data.&quot;</span>), vm);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">props</span> &amp;&amp; key <span class="keyword">in</span> vm.<span class="property">$options</span>.<span class="property">props</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>((<span class="string">&quot;The computed property \&quot;&quot;</span> + key + <span class="string">&quot;\&quot; is already defined as a prop.&quot;</span>), vm);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">methods</span> &amp;&amp; key <span class="keyword">in</span> vm.<span class="property">$options</span>.<span class="property">methods</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>((<span class="string">&quot;The computed property \&quot;&quot;</span> + key + <span class="string">&quot;\&quot; is already defined as a method.&quot;</span>), vm);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先创建了一个computed专用的watcher数组</li><li>遍历每一个computed，同时为他们每一个创建一个watcher</li><li>最后defineComputed函数则把computed挂载到vm上，内部实际使用的是watcher的方法</li></ul><h5 id="initWatch"><a href="#initWatch" class="headerlink" title="initWatch"></a>initWatch</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initWatch</span> (vm, watch) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">var</span> handler = watch[key];</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handler.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">createWatcher</span>(vm, key, handler[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">createWatcher</span>(vm, key, handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历用户的watcher创建，内部使用<code>Vue.$watch</code>方法</li><li><code>Vue.$watch</code>方法则是使用watcher（观察者实现）</li></ul><h4 id="initProvide"><a href="#initProvide" class="headerlink" title="initProvide"></a>initProvide</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initProvide</span> (vm) &#123;</span><br><span class="line">  <span class="keyword">var</span> provide = vm.<span class="property">$options</span>.<span class="property">provide</span>;</span><br><span class="line">  <span class="keyword">if</span> (provide) &#123;</span><br><span class="line">    vm.<span class="property">_provided</span> = <span class="keyword">typeof</span> provide === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">      ? provide.<span class="title function_">call</span>(vm)</span><br><span class="line">      : provide;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>存在provide就挂载到vm上</li></ul><h4 id="callHook-‘created’"><a href="#callHook-‘created’" class="headerlink" title="callHook(‘created’)"></a>callHook(‘created’)</h4><ul><li>和之前的生命周期函数相同，此时调用<code>created</code>生命周期函数</li></ul><h3 id="mount"><a href="#mount" class="headerlink" title="$mount"></a>$mount</h3><ul><li><code>_init</code>函数的最后一步（如果存在el属性）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el,</span></span><br><span class="line"><span class="params">  hydrating</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  el = el &amp;&amp; <span class="title function_">query</span>(el);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">&quot;Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> options = <span class="variable language_">this</span>.<span class="property">$options</span>;</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> template = options.<span class="property">template</span>;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">          template = <span class="title function_">idToTemplate</span>(template);</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">              (<span class="string">&quot;Template element not found or is empty: &quot;</span> + (options.<span class="property">template</span>)),</span><br><span class="line">              <span class="variable language_">this</span></span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;</span><br><span class="line">        template = template.<span class="property">innerHTML</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          <span class="title function_">warn</span>(<span class="string">&#x27;invalid template option:&#x27;</span> + template, <span class="variable language_">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      template = <span class="title function_">getOuterHTML</span>(el);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        <span class="title function_">mark</span>(<span class="string">&#x27;compile&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> ref = <span class="title function_">compileToFunctions</span>(template, &#123;</span><br><span class="line">        <span class="attr">outputSourceRange</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">        <span class="attr">shouldDecodeNewlines</span>: shouldDecodeNewlines,</span><br><span class="line">        <span class="attr">shouldDecodeNewlinesForHref</span>: shouldDecodeNewlinesForHref,</span><br><span class="line">        <span class="attr">delimiters</span>: options.<span class="property">delimiters</span>,</span><br><span class="line">        <span class="attr">comments</span>: options.<span class="property">comments</span></span><br><span class="line">      &#125;, <span class="variable language_">this</span>);</span><br><span class="line">      <span class="keyword">var</span> render = ref.<span class="property">render</span>;</span><br><span class="line">      <span class="keyword">var</span> staticRenderFns = ref.<span class="property">staticRenderFns</span>;</span><br><span class="line">      options.<span class="property">render</span> = render;</span><br><span class="line">      options.<span class="property">staticRenderFns</span> = staticRenderFns;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">        <span class="title function_">mark</span>(<span class="string">&#x27;compile end&#x27;</span>);</span><br><span class="line">        <span class="title function_">measure</span>((<span class="string">&quot;vue &quot;</span> + (<span class="variable language_">this</span>.<span class="property">_name</span>) + <span class="string">&quot; compile&quot;</span>), <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.<span class="title function_">call</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>首先使用<code>query</code>函数查询<code>el</code>指定的DOM节点</p></li><li><p><strong>然后检查<code>template</code>并将模板编译为渲染函数（render）</strong></p><ul><li><strong>模板编译函数：compileToFunctions</strong><ul><li><strong>内部会将template处理为ast，然后转换为<code>$createElement</code>函数可以处理的VDOM，<code>$createElement</code>处理之后就会生成VNode</strong></li></ul></li><li><strong>这也是Vue可以支持JSX写法的原因</strong></li></ul></li><li><p>最后调用mount函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public mount method</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el,</span></span><br><span class="line"><span class="params">  hydrating</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? <span class="title function_">query</span>(el) : <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountComponent</span>(<span class="variable language_">this</span>, el, hydrating)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>注意这个mount和之前的$mount函数不同</li></ul></li></ul><h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mountComponent</span> (</span><br><span class="line">  vm,</span><br><span class="line">  el,</span><br><span class="line">  hydrating</span><br><span class="line">) &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el;</span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.<span class="property">$options</span>.<span class="property">template</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">template</span>.<span class="title function_">charAt</span>(<span class="number">0</span>) !== <span class="string">&#x27;#&#x27;</span>) ||</span><br><span class="line">        vm.<span class="property">$options</span>.<span class="property">el</span> || el) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> updateComponent;</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> name = vm.<span class="property">_name</span>;</span><br><span class="line">      <span class="keyword">var</span> id = vm.<span class="property">_uid</span>;</span><br><span class="line">      <span class="keyword">var</span> startTag = <span class="string">&quot;vue-perf-start:&quot;</span> + id;</span><br><span class="line">      <span class="keyword">var</span> endTag = <span class="string">&quot;vue-perf-end:&quot;</span> + id;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag);</span><br><span class="line">      <span class="keyword">var</span> vnode = vm.<span class="title function_">_render</span>();</span><br><span class="line">      <span class="title function_">mark</span>(endTag);</span><br><span class="line">      <span class="title function_">measure</span>((<span class="string">&quot;vue &quot;</span> + name + <span class="string">&quot; render&quot;</span>), startTag, endTag);</span><br><span class="line"></span><br><span class="line">      <span class="title function_">mark</span>(startTag);</span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating);</span><br><span class="line">      <span class="title function_">mark</span>(endTag);</span><br><span class="line">      <span class="title function_">measure</span>((<span class="string">&quot;vue &quot;</span> + name + <span class="string">&quot; patch&quot;</span>), startTag, endTag);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    <span class="attr">before</span>: <span class="keyword">function</span> <span class="title function_">before</span> () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>);</span><br><span class="line">  hydrating = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先会检测option的render函数是否存在（template编译的或者JSX）</li><li><strong>接着执行<code>beforeMounted</code>生命周期函数</strong></li><li><strong>创建<code>updateComponent</code>函数，内部使用<code>vm._udpate(vm._render)</code></strong></li><li>以<code>updateComponent</code>函数为<code>exprOrFn</code>创建watcher</li><li>最后执行本组件的<code>mounted</code>生命周期函数</li></ul><h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Watcher</span> = <span class="keyword">function</span> <span class="title function_">Watcher</span> (</span><br><span class="line">  vm,</span><br><span class="line">  expOrFn,</span><br><span class="line">  cb,</span><br><span class="line">  options,</span><br><span class="line">  isRenderWatcher</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">  <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">    vm.<span class="property">_watcher</span> = <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  vm.<span class="property">_watchers</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="comment">// options</span></span><br><span class="line">  <span class="keyword">if</span> (options) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deep</span> = !!options.<span class="property">deep</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = !!options.<span class="property">user</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lazy</span> = !!options.<span class="property">lazy</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sync</span> = !!options.<span class="property">sync</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">before</span> = options.<span class="property">before</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deep</span> = <span class="variable language_">this</span>.<span class="property">user</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> = <span class="variable language_">this</span>.<span class="property">sync</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">cb</span> = cb;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">id</span> = ++uid$<span class="number">2</span>; <span class="comment">// uid for batching</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="variable language_">this</span>.<span class="property">lazy</span>; <span class="comment">// for lazy watchers</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">deps</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDeps</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="keyword">new</span> <span class="title function_">_Set</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDepIds</span> = <span class="keyword">new</span> <span class="title function_">_Set</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">expression</span> = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">    ? expOrFn.<span class="title function_">toString</span>()</span><br><span class="line">    : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">// parse expression for getter</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">getter</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = noop;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&quot;Failed watching path: \&quot;&quot;</span> + expOrFn + <span class="string">&quot;\&quot; &quot;</span> +</span><br><span class="line">        <span class="string">&#x27;Watcher only accepts simple dot-delimited paths. &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;For full control, use a function instead.&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span></span><br><span class="line">    ? <span class="literal">undefined</span></span><br><span class="line">    : <span class="variable language_">this</span>.<span class="title function_">get</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>Watcher初始化最后会通过<code>get</code>函数获取初始值</p></li><li><p><strong><code>get</code>函数则是通过调用Watcher初始化的getter获取值</strong></p><ul><li><p>那么最后就是调用<code>mountComponent</code>函数中声明的<code>updateComponent</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="render"><a href="#render" class="headerlink" title="_render"></a>_render</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">var</span> ref = vm.<span class="property">$options</span>;</span><br><span class="line">    <span class="keyword">var</span> render = ref.<span class="property">render</span>;</span><br><span class="line">    <span class="keyword">var</span> _parentVnode = ref.<span class="property">_parentVnode</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">        vm.<span class="property">$scopedSlots</span> = <span class="title function_">normalizeScopedSlots</span>(</span><br><span class="line">            _parentVnode.<span class="property">data</span>.<span class="property">scopedSlots</span>,</span><br><span class="line">            vm.<span class="property">$slots</span>,</span><br><span class="line">            vm.<span class="property">$scopedSlots</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.<span class="property">$vnode</span> = _parentVnode;</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">var</span> vnode;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// There&#x27;s no need to maintain a stack because all render fns are called</span></span><br><span class="line">        <span class="comment">// separately from one another. Nested component&#x27;s render fns are called</span></span><br><span class="line">        <span class="comment">// when parent component is patched.</span></span><br><span class="line">        currentRenderingInstance = vm;</span><br><span class="line">        vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">&quot;render&quot;</span>);</span><br><span class="line">        <span class="comment">// return error render result,</span></span><br><span class="line">        <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">        <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; vm.<span class="property">$options</span>.<span class="property">renderError</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                vnode = vm.<span class="property">$options</span>.<span class="property">renderError</span>.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="title function_">handleError</span>(e, vm, <span class="string">&quot;renderError&quot;</span>);</span><br><span class="line">                vnode = vm.<span class="property">_vnode</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vnode = vm.<span class="property">_vnode</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentRenderingInstance = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode) &amp;&amp; vnode.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        vnode = vnode[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">            <span class="title function_">warn</span>(</span><br><span class="line">                <span class="string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">                vm</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        vnode = <span class="title function_">createEmptyVNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.<span class="property">parent</span> = _parentVnode;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>_render</code>函数主要通过传入<code>$createElement</code>函数生成VNode，并返回</strong></li></ul><h4 id="update"><a href="#update" class="headerlink" title="_update"></a>_update</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode, hydrating</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">var</span> prevEl = vm.<span class="property">$el</span>;</span><br><span class="line">  <span class="keyword">var</span> prevVnode = vm.<span class="property">_vnode</span>;</span><br><span class="line">  <span class="keyword">var</span> restoreActiveInstance = <span class="title function_">setActiveInstance</span>(vm);</span><br><span class="line">  vm.<span class="property">_vnode</span> = vnode;</span><br><span class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">  <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render</span></span><br><span class="line">    vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates</span></span><br><span class="line">    vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">restoreActiveInstance</span>();</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.<span class="property">__vue__</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$el</span>) &#123;</span><br><span class="line">    vm.<span class="property">$el</span>.<span class="property">__vue__</span> = vm;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> &amp;&amp; vm.<span class="property">$parent</span> &amp;&amp; vm.<span class="property">$vnode</span> === vm.<span class="property">$parent</span>.<span class="property">_vnode</span>) &#123;</span><br><span class="line">    vm.<span class="property">$parent</span>.<span class="property">$el</span> = vm.<span class="property">$el</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">  <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>_update</code>函数主要通过patch函数将VNode转化为实际DOM</strong></li></ul><h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span> (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode)) &#123;</span><br><span class="line">        <span class="comment">// 无新VNode，存在旧VNode，删除旧VNode即可</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode)) &#123; <span class="title function_">invokeDestroyHook</span>(oldVnode); &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isInitialPatch = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> insertedVnodeQueue = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode)) &#123;</span><br><span class="line">        <span class="comment">// 不存在旧节点，直接根据新VNode创建新节点即可</span></span><br><span class="line">        <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">        isInitialPatch = <span class="literal">true</span>;</span><br><span class="line">        <span class="title function_">createElm</span>(vnode, insertedVnodeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> isRealElement = <span class="title function_">isDef</span>(oldVnode.<span class="property">nodeType</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isRealElement &amp;&amp; <span class="title function_">sameVnode</span>(oldVnode, vnode)) &#123;</span><br><span class="line">            <span class="comment">// patch existing root node</span></span><br><span class="line">            <span class="title function_">patchVnode</span>(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">                <span class="comment">// mounting to a real element</span></span><br><span class="line">                <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">                <span class="comment">// a successful hydration.</span></span><br><span class="line">                <span class="keyword">if</span> (oldVnode.<span class="property">nodeType</span> === <span class="number">1</span> &amp;&amp; oldVnode.<span class="title function_">hasAttribute</span>(<span class="variable constant_">SSR_ATTR</span>)) &#123;</span><br><span class="line">                    oldVnode.<span class="title function_">removeAttribute</span>(<span class="variable constant_">SSR_ATTR</span>);</span><br><span class="line">                    hydrating = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isTrue</span>(hydrating)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">hydrate</span>(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">                        <span class="title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, <span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> oldVnode</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">                        <span class="title function_">warn</span>(</span><br><span class="line">                            <span class="string">&#x27;The client-side rendered virtual DOM tree is not matching &#x27;</span> +</span><br><span class="line">                            <span class="string">&#x27;server-rendered content. This is likely caused by incorrect &#x27;</span> +</span><br><span class="line">                            <span class="string">&#x27;HTML markup, for example nesting block-level elements inside &#x27;</span> +</span><br><span class="line">                            <span class="string">&#x27;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &#x27;</span> +</span><br><span class="line">                            <span class="string">&#x27;full client-side render.&#x27;</span></span><br><span class="line">                        );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// either not server-rendered, or hydration failed.</span></span><br><span class="line">                <span class="comment">// create an empty node and replace it</span></span><br><span class="line">                oldVnode = <span class="title function_">emptyNodeAt</span>(oldVnode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// replacing existing element</span></span><br><span class="line">            <span class="keyword">var</span> oldElm = oldVnode.<span class="property">elm</span>;</span><br><span class="line">            <span class="keyword">var</span> parentElm = nodeOps.<span class="title function_">parentNode</span>(oldElm);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// create new node</span></span><br><span class="line">            <span class="title function_">createElm</span>(</span><br><span class="line">                vnode,</span><br><span class="line">                insertedVnodeQueue,</span><br><span class="line">                <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">                <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">                <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">                oldElm.<span class="property">_leaveCb</span> ? <span class="literal">null</span> : parentElm,</span><br><span class="line">                nodeOps.<span class="title function_">nextSibling</span>(oldElm)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update parent placeholder node element, recursively</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">parent</span>)) &#123;</span><br><span class="line">                <span class="keyword">var</span> ancestor = vnode.<span class="property">parent</span>;</span><br><span class="line">                <span class="keyword">var</span> patchable = <span class="title function_">isPatchable</span>(vnode);</span><br><span class="line">                <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cbs.<span class="property">destroy</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">                        cbs.<span class="property">destroy</span>[i](ancestor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ancestor.<span class="property">elm</span> = vnode.<span class="property">elm</span>;</span><br><span class="line">                    <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> i$<span class="number">1</span> = <span class="number">0</span>; i$<span class="number">1</span> &lt; cbs.<span class="property">create</span>.<span class="property">length</span>; ++i$<span class="number">1</span>) &#123;</span><br><span class="line">                            cbs.<span class="property">create</span>[i$<span class="number">1</span>](emptyNode, ancestor);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// #6513</span></span><br><span class="line">                        <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></span><br><span class="line">                        <span class="comment">// e.g. for directives that uses the &quot;inserted&quot; hook.</span></span><br><span class="line">                        <span class="keyword">var</span> insert = ancestor.<span class="property">data</span>.<span class="property">hook</span>.<span class="property">insert</span>;</span><br><span class="line">                        <span class="keyword">if</span> (insert.<span class="property">merged</span>) &#123;</span><br><span class="line">                            <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">var</span> i$<span class="number">2</span> = <span class="number">1</span>; i$<span class="number">2</span> &lt; insert.<span class="property">fns</span>.<span class="property">length</span>; i$<span class="number">2</span>++) &#123;</span><br><span class="line">                                insert.<span class="property">fns</span>[i$<span class="number">2</span>]();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="title function_">registerRef</span>(ancestor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ancestor = ancestor.<span class="property">parent</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// destroy old node</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isDef</span>(parentElm)) &#123;</span><br><span class="line">                <span class="title function_">removeVnodes</span>([oldVnode], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">tag</span>)) &#123;</span><br><span class="line">                <span class="title function_">invokeDestroyHook</span>(oldVnode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">invokeInsertHook</span>(vnode, insertedVnodeQueue, isInitialPatch);</span><br><span class="line">    <span class="keyword">return</span> vnode.<span class="property">elm</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>patch</code>函数是真正更新DOM的重要函数，根据情况不同，更新方式也不同</strong></p><ul><li><strong><code>patchVnode</code>函数用于更新已存在的DOM，著名的DIFF算法就在其中</strong></li></ul></li><li><p><strong><code>createElm</code>函数根据VNode创建真实DOM节点，随后插入真实DOM树</strong></p><ul><li><strong>前面进行一些判断简化操作，最后去除oldDOM节点</strong></li></ul></li></ul><h4 id="createElm"><a href="#createElm" class="headerlink" title="createElm"></a>createElm</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElm</span> (</span><br><span class="line">vnode,</span><br><span class="line"> insertedVnodeQueue,</span><br><span class="line"> parentElm,</span><br><span class="line"> refElm,</span><br><span class="line"> nested,</span><br><span class="line"> ownerArray,</span><br><span class="line"> index</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">elm</span>) &amp;&amp; <span class="title function_">isDef</span>(ownerArray)) &#123;</span><br><span class="line">        <span class="comment">// This vnode was used in a previous render!</span></span><br><span class="line">        <span class="comment">// now it&#x27;s used as a new node, overwriting its elm would cause</span></span><br><span class="line">        <span class="comment">// potential patch errors down the road when it&#x27;s used as an insertion</span></span><br><span class="line">        <span class="comment">// reference node. Instead, we clone the node on-demand before creating</span></span><br><span class="line">        <span class="comment">// associated DOM element for it.</span></span><br><span class="line">        vnode = ownerArray[index] = <span class="title function_">cloneVNode</span>(vnode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vnode.<span class="property">isRootInsert</span> = !nested; <span class="comment">// for transition enter check</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">createComponent</span>(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data = vnode.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">var</span> children = vnode.<span class="property">children</span>;</span><br><span class="line">    <span class="keyword">var</span> tag = vnode.<span class="property">tag</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(tag)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &amp;&amp; data.<span class="property">pre</span>) &#123;</span><br><span class="line">                creatingElmInVPre++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isUnknownElement$$1</span>(vnode, creatingElmInVPre)) &#123;</span><br><span class="line">                <span class="title function_">warn</span>(</span><br><span class="line">                    <span class="string">&#x27;Unknown custom element: &lt;&#x27;</span> + tag + <span class="string">&#x27;&gt; - did you &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;register the component correctly? For recursive components, &#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;make sure to provide the &quot;name&quot; option.&#x27;</span>,</span><br><span class="line">                    vnode.<span class="property">context</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vnode.<span class="property">elm</span> = vnode.<span class="property">ns</span></span><br><span class="line">            ? nodeOps.<span class="title function_">createElementNS</span>(vnode.<span class="property">ns</span>, tag)</span><br><span class="line">        : nodeOps.<span class="title function_">createElement</span>(tag, vnode);</span><br><span class="line">        <span class="title function_">setScope</span>(vnode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="title function_">createChildren</span>(vnode, children, insertedVnodeQueue);</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) &#123;</span><br><span class="line">                <span class="title function_">invokeCreateHooks</span>(vnode, insertedVnodeQueue);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; data &amp;&amp; data.<span class="property">pre</span>) &#123;</span><br><span class="line">            creatingElmInVPre--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isTrue</span>(vnode.<span class="property">isComment</span>)) &#123;</span><br><span class="line">        vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createComment</span>(vnode.<span class="property">text</span>);</span><br><span class="line">        <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createTextNode</span>(vnode.<span class="property">text</span>);</span><br><span class="line">        <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>如果是组件会去使用<code>createComponent</code>函数创建组件</strong></p></li><li><p><strong>如果是已知的HTML标签，会直接使用<code>nodeOps.createElement</code>函数创建</strong></p><ul><li><p><strong><code>nodeOps.createElement</code>函数内部使用原生DOM操作</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElement$1</span> (tagName, vnode) &#123;</span><br><span class="line">  <span class="keyword">var</span> elm = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(tagName);</span><br><span class="line">  <span class="keyword">if</span> (tagName !== <span class="string">&#x27;select&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> elm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// false or null will remove the attribute but undefined will not</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">data</span> &amp;&amp; vnode.<span class="property">data</span>.<span class="property">attrs</span> &amp;&amp; vnode.<span class="property">data</span>.<span class="property">attrs</span>.<span class="property">multiple</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    elm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;multiple&#x27;</span>, <span class="string">&#x27;multiple&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> elm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>如果存在子节点，则会调用<code>createChildren</code>函数创建子节点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createChildren</span> (vnode, children, insertedVnodeQueue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">checkDuplicateKeys</span>(children);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">            <span class="title function_">createElm</span>(children[i], insertedVnodeQueue, vnode.<span class="property">elm</span>, <span class="literal">null</span>, <span class="literal">true</span>, children, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isPrimitive</span>(vnode.<span class="property">text</span>)) &#123;</span><br><span class="line">        nodeOps.<span class="title function_">appendChild</span>(vnode.<span class="property">elm</span>, nodeOps.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(vnode.<span class="property">text</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>递归调用<code>createElm</code>函数创建子节点的真实DOM</strong></li></ul></li><li><p><strong>如果是文本节点或注释节点，则分别使用对应的原生DOM操作去创建</strong></p></li><li><p><strong>创建完成之后调用<code>insert</code>函数插入父节点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span> (parent, elm, ref$$1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(parent)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(ref$$1)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeOps.<span class="title function_">parentNode</span>(ref$$1) === parent) &#123;</span><br><span class="line">                nodeOps.<span class="title function_">insertBefore</span>(parent, elm, ref$$1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodeOps.<span class="title function_">appendChild</span>(parent, elm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意此时父节点可能没有挂载到视图上（例如：根Vue），所以没有在视图上展示</strong></li></ul></li></ul><h4 id="createComponent"><a href="#createComponent" class="headerlink" title="createComponent"></a>createComponent</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComponent</span> (vnode, insertedVnodeQueue, parentElm, refElm) &#123;</span><br><span class="line">    <span class="keyword">var</span> i = vnode.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(i)) &#123;</span><br><span class="line">        <span class="keyword">var</span> isReactivated = <span class="title function_">isDef</span>(vnode.<span class="property">componentInstance</span>) &amp;&amp; i.<span class="property">keepAlive</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = i.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">init</span>)) &#123;</span><br><span class="line">            <span class="title function_">i</span>(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// after calling the init hook, if the vnode is a child component</span></span><br><span class="line">        <span class="comment">// it should&#x27;ve created a child instance and mounted it. the child</span></span><br><span class="line">        <span class="comment">// component also has set the placeholder vnode&#x27;s elm.</span></span><br><span class="line">        <span class="comment">// in that case we can just return the element and be done.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">componentInstance</span>)) &#123;</span><br><span class="line">            <span class="title function_">initComponent</span>(vnode, insertedVnodeQueue);</span><br><span class="line">            <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm);</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isTrue</span>(isReactivated)) &#123;</span><br><span class="line">                <span class="title function_">reactivateComponent</span>(vnode, insertedVnodeQueue, parentElm, refElm);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>组件的VNode的data存有hook函数，是由<code>render</code>函数注入的？componentOptions属性存有组件的<code>props、tag、listeners、Ctor</code>（Ctor是VueComponent函数，tag是我们定义的组件名）</p></li><li><p><code>init</code>hook函数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">init</span> (vnode, hydrating) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        vnode.<span class="property">componentInstance</span> &amp;&amp;</span><br><span class="line">        !vnode.<span class="property">componentInstance</span>.<span class="property">_isDestroyed</span> &amp;&amp;</span><br><span class="line">        vnode.<span class="property">data</span>.<span class="property">keepAlive</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">        <span class="keyword">var</span> mountedNode = vnode; <span class="comment">// work around flow</span></span><br><span class="line">        componentVNodeHooks.<span class="title function_">prepatch</span>(mountedNode, mountedNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> child = vnode.<span class="property">componentInstance</span> = <span class="title function_">createComponentInstanceForVnode</span>(</span><br><span class="line">            vnode,</span><br><span class="line">            activeInstance</span><br><span class="line">        );</span><br><span class="line">        child.$mount(hydrating ? vnode.<span class="property">elm</span> : <span class="literal">undefined</span>, hydrating);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li><strong><code>createComponentInstanceForVnode</code>函数会调用VueComponent的构造函数，最后调用Vue.__init函数</strong></li><li><strong>由于没有<code>el</code>属性，子组件<code>init</code>之后就会返回<code>VueComponent</code>对象（不会自动调用<code>init</code>的$mount函数进行挂载）</strong><ul><li>随后<code>init</code>函数进行手动挂载</li></ul></li></ul></li></ul><h4 id="invokeInsertHook"><a href="#invokeInsertHook" class="headerlink" title="invokeInsertHook"></a>invokeInsertHook</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invokeInsertHook</span> (vnode, queue, initial) &#123;</span><br><span class="line">    <span class="comment">// delay insert hooks for component root nodes, invoke them after the</span></span><br><span class="line">    <span class="comment">// element is really inserted</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTrue</span>(initial) &amp;&amp; <span class="title function_">isDef</span>(vnode.<span class="property">parent</span>)) &#123;</span><br><span class="line">        vnode.<span class="property">parent</span>.<span class="property">data</span>.<span class="property">pendingInsert</span> = queue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; queue.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">            queue[i].<span class="property">data</span>.<span class="property">hook</span>.<span class="title function_">insert</span>(queue[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>子组件的<code>insert</code>hook都会保留到父组件<code>patch</code>函数结尾执行</strong><ul><li><strong><code>mounted</code>声明周期函数在此处执行</strong></li><li><strong><code>v-model</code>指令在此处会在DOM节点上绑定相关事件，实现双向绑定</strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> source </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue响应式原理的简单探索</title>
      <link href="/2021/06/04/vueReactive/"/>
      <url>/2021/06/04/vueReactive/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>_Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统_——Vue官方文档</p><ul><li><p>第一个例子（只保留核心代码）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>之后在页面上会看见<code>Hello Vue!</code>，而且<strong>数据是具有响应式的</strong>，也就是说修改<code>app.message</code>，页面上的值也会发生变化</li><li>下面来分析如何简单实现<code>Vue</code>的响应式</li></ul></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="数据渲染"><a href="#数据渲染" class="headerlink" title="数据渲染"></a>数据渲染</h3><ul><li><p>先思考怎么把数据渲染到视图上，一般我们的方法都是通过JavaScript操作DOM，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerHTML</span> = msg;</span><br></pre></td></tr></table></figure><p>效果如下：</p><img src="/2021/06/04/vueReactive/1.png" class="" title="效果图"></li><li><p>之后修改变量时，想要修改视图，明显需要继续利用JavaScript操作DOM，<strong>重复的操作明显可以使用函数封装</strong>，可以先把JavaScript修改DOM的操作封装为一个函数，然后在适当地时候调用即可，例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="title function_">update</span>();</span><br><span class="line"><span class="comment">//异步操作效果更清晰</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    msg = <span class="string">&#x27;456&#x27;</span>;</span><br><span class="line">    <span class="title function_">update</span>();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">//update函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerHTML</span> = msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>效果如下（1秒后数据变化，DOM也变化）：</p><img src="/2021/06/04/vueReactive/2.gif" class="" title="效果图"><h3 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h3><ul><li>那我们想做到变量<code>msg</code>变化，视图就变化（Vue所做到的），该怎么办呢？答案很清晰使用某种办法，<strong>在<code>msg</code>变化之后立即调用<code>update</code>函数，那么这里就要使用数据劫持</strong></li></ul><h4 id="getter和setter"><a href="#getter和setter" class="headerlink" title="getter和setter"></a>getter和setter</h4><ul><li><p>在JavaScript的属性描述符中有这两种特殊的描述符<code>setter</code>和<code>getter</code>，它们的作用如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">_a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_a</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_a</span> = val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果如下：</p><img src="/2021/06/04/vueReactive/3.gif" class="" title="效果图"><ul><li>可以看到<code>setter</code>和<code>getter</code>代理了<code>obj._a</code>（<strong>ES6提出了<code>Proxy</code>来规范代理同时也是Vue3数据劫持所采用的方案</strong>）</li></ul></li></ul><h3 id="实现同步更新"><a href="#实现同步更新" class="headerlink" title="实现同步更新"></a>实现同步更新</h3><ul><li><p>利用属性描述符，我们就可以做到数据和视图同步更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//data数据</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    <span class="attr">_msg</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//数据劫持</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;msg&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_msg</span> = val;</span><br><span class="line">        <span class="comment">//数据更新完成后更新视图</span></span><br><span class="line">        <span class="title function_">update</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_msg</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">innerHTML</span> = data.<span class="property">msg</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">data.<span class="property">msg</span> = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    data.<span class="property">msg</span> = <span class="string">&#x27;456&#x27;</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>效果如下：</p><img src="/2021/06/04/vueReactive/4.gif" class="" title="效果图"><ul><li>至此最基础简单的响应式就完成了</li></ul></li></ul><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><ul><li><p>由于数据可能会和其他数据产生互动，可能渲染到多个组件中，确保它的正确渲染Vue采用了观察者模式设计了依赖收集机制</p></li><li><p>订阅者（简化版）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span> = [];<span class="comment">//订阅数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addSub</span>(<span class="params">watcher</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(watcher)<span class="comment">//添加一个watcher</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">watcher</span>) =&gt;</span> &#123;</span><br><span class="line">            watcher.<span class="title function_">update</span>()<span class="comment">//执行所有watcher的update</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>订阅者收集所有watcher，并在合适的时候通知所有watcher更新视图</li></ul></li><li><p>观察者（简化版）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">obj, key, cb</span>) &#123;</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;<span class="comment">//确保Dep的对象是这个watcher</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = obj[key];<span class="comment">//获取值，主要为了触发getter</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">obj</span> = obj;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cb</span> = cb;<span class="comment">//更新逻辑</span></span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span><span class="comment">//防止watcher重复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = <span class="variable language_">this</span>.<span class="property">obj</span>[<span class="variable language_">this</span>.<span class="property">key</span>];<span class="comment">//获取最新的值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">cb</span>(<span class="variable language_">this</span>.<span class="property">val</span>)<span class="comment">//根据回调函数的逻辑更新视图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意每个watcher的构造函数实例化调用一次，触发一次getter，则每个watcher都可以负责一个值的视图更新逻辑</li></ul></li><li><p>数据劫持（简化版）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> data) &#123;<span class="comment">//遍历data，劫持每一个属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(data, key)) &#123;<span class="comment">//确保在data上</span></span><br><span class="line">        <span class="keyword">let</span> value = data[key];<span class="comment">//获取原值</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">            <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;<span class="comment">//配合watcher的构造函数</span></span><br><span class="line">                    dep.<span class="title function_">addSub</span>(<span class="title class_">Dep</span>.<span class="property">target</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">                value = val;</span><br><span class="line">                dep.<span class="title function_">notify</span>();<span class="comment">//值发生了变化，通知所有watcher进行更新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成观察者</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(data, <span class="string">&#x27;pri1&#x27;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//pri1的更新逻辑</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.pri1&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;pri1:&#x27;</span> + val;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.total&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;total:&#x27;</span> + (val + data.<span class="property">pri2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Watcher</span>(data, <span class="string">&#x27;pri2&#x27;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//pri2的更新逻辑</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.pri2&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;pri2:&#x27;</span> + val;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.total&#x27;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;total:&#x27;</span> + (val + data.<span class="property">pri1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>实际Vue当中不会一个一个手动生成watcher，会根据表达式推断视图更新逻辑</li></ul><p>效果如下：</p><img src="/2021/06/04/vueReactive/5.gif" class="" title="效果图"></li><li><p>至此Vue响应式最基础的原理就差不多了，但Vue对此做了很多优化以匹配很多机制</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动实现一个简单的async</title>
      <link href="/2021/05/31/wirteMyAsync/"/>
      <url>/2021/05/31/wirteMyAsync/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p><strong>async函数只是promise+generator函数的语法糖</strong></p><ul><li>具体可见《你不懂的JavaScript》中卷</li></ul></li><li><p>promise+generator函数可以使用同步计划书写异步逻辑，更符合人类习惯去书写异步代码</p><ul><li><strong>async函数进一步简化了上述代码</strong></li></ul></li></ul><h2 id="手写源码连接"><a href="#手写源码连接" class="headerlink" title="手写源码连接"></a>手写源码连接</h2><p><a href="https://juejin.cn/post/6844904102053281806">来自晨曦时梦见兮大佬</a></p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getData</span> = (<span class="params"></span>) =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;data&quot;</span>), <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">getData</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data: &#x27;</span>, data);</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> <span class="title function_">getData</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data2: &#x27;</span>, data2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;success&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样的一个函数 应该再1秒后打印data 再过一秒打印data2 最后打印success</span></span><br><span class="line"><span class="title function_">test</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure><p>代码效果</p><img src="/2021/05/31/wirteMyAsync/1.gif" class="" title="效果图"><ul><li>可以看到使用async函数，await标识出异步代码，js执行时就会在进行异步阻塞，整个async函数会停止下来<ul><li>关于async函数具体使用见<a href="https://es6.ruanyifeng.com/#docs/async">阮一峰大佬的教学</a></li></ul></li></ul><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="generator函数形式"><a href="#generator函数形式" class="headerlink" title="generator函数形式"></a>generator函数形式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getData</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">testG</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">yield</span> <span class="title function_">getData</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data:&quot;</span>, data);</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> <span class="title function_">getData</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data2:&quot;</span>, data2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getData函数不变</li><li><strong>test函数async使用generator函数标识符*代替，所有await使用yield代替</strong></li></ul><h3 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="title function_">testG</span>()<span class="comment">//获取迭代器实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dataPromise = gen.<span class="title function_">next</span>()<span class="comment">//获取第一个promise</span></span><br><span class="line"></span><br><span class="line">dataPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">value1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// data1的value被拿到了 继续调用next并且传递给data 并获取第二个promise</span></span><br><span class="line">    <span class="keyword">var</span> data2Promise = gen.<span class="title function_">next</span>(value1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// console.log(&#x27;data: &#x27;, data);</span></span><br><span class="line">    <span class="comment">// 此时就会打印出data</span></span><br><span class="line">    </span><br><span class="line">    data2Promise.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">value2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// data2的value拿到了 继续调用next并且传递value2</span></span><br><span class="line">         gen.<span class="title function_">next</span>(value2)</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// console.log(&#x27;data2: &#x27;, data2);</span></span><br><span class="line">        <span class="comment">// 此时就会打印出data2</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>手动调用generator函数，实现异步操作</li></ul><h3 id="利用高阶函数实现自动执行"><a href="#利用高阶函数实现自动执行" class="headerlink" title="利用高阶函数实现自动执行"></a>利用高阶函数实现自动执行</h3><ul><li><p>期望的终极形态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncToGenerator</span>(testG).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res));</span><br><span class="line"><span class="comment">//传入一个生成器函数，asyncToGenerator函数会自动执行完，并返回一个promise</span></span><br></pre></td></tr></table></figure><ul><li>那么asyncToGenerator函数最后应该返回一个promise</li></ul></li><li><p><strong>连续的promise调用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">testG</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">yield</span> <span class="title function_">getData</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data:&quot;</span>, data);</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> <span class="title function_">getData</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data2:&quot;</span>, data2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>generator函数可能存在多个promise，需要一步一步自己调用解包</p></li><li><p>怎么重复调用是重点，而解决思路是找到链式调用的节点</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//retPromise就是generator函数返回的promise</span></span><br><span class="line">retPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//it就是迭代器 即在一个promise状态确定后，根据状态进行下一步。例如resolve下，应该将值返回去，接受下一个promise</span></span><br><span class="line">    it.<span class="title function_">next</span>(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>将这里的逻辑抽离出来形成函数，然后在合适的时间调用即可</li></ul></li><li><p>最终实现的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncToGenerator</span>(<span class="params">generatorFunc</span>) &#123;</span><br><span class="line">  <span class="comment">//获取generator函数的迭代器</span></span><br><span class="line">  <span class="keyword">let</span> it = <span class="title function_">generatorFunc</span>();</span><br><span class="line">  <span class="comment">//返回一个新的promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//step函数用于调用下一个promise</span></span><br><span class="line">    <span class="comment">//key为迭代器运行方式，val为迭代器要传递进去的参数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">key, val</span>) &#123;</span><br><span class="line">      <span class="comment">//generator函数返回的value，由于try属于特殊的上下文，变量需要定义在外部</span></span><br><span class="line">      <span class="keyword">let</span> retPromise;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        retPromise = it[key](val); <span class="comment">//迭代器运行</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e); <span class="comment">//出错直接由外部捕获</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; value, done &#125; = retPromise; <span class="comment">//从generator函数返回的值</span></span><br><span class="line">      <span class="comment">//value即是promise,done用于确定迭代器是否迭代完毕</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="comment">//如果迭代完毕了，直接向外部抛出最后的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果没有，调用generator函数返回的promise，注册then事件</span></span><br><span class="line">        <span class="keyword">return</span> value.<span class="title function_">then</span>(</span><br><span class="line">          <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//generator函数返回的promise变为resolve时，把获取的值传入step函数，并指示迭代器进行下一步</span></span><br><span class="line">            <span class="title function_">step</span>(<span class="string">&quot;next&quot;</span>, val);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//逻辑同上</span></span><br><span class="line">            <span class="title function_">step</span>(<span class="string">&quot;throw&quot;</span>, err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始迭代，第一个不需要参数，直接下一步即可</span></span><br><span class="line">    <span class="title function_">step</span>(<span class="string">&quot;next&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最终效果</p><img src="/2021/05/31/wirteMyAsync/2.gif" class="" title="效果图"></li></ul><p>–</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次对webpack输出文件的分析</title>
      <link href="/2021/05/25/webpackOutFileAnalyes/"/>
      <url>/2021/05/25/webpackOutFileAnalyes/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack-5-37-0-的输出文件分析"><a href="#webpack-5-37-0-的输出文件分析" class="headerlink" title="webpack 5.37.0 的输出文件分析"></a>webpack 5.37.0 的输出文件分析</h2><ul><li><p>入口文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> show <span class="keyword">from</span> <span class="string">&quot;./tmp2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">show</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1111&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>依赖文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tmp2.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">arg</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;show me!&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`arg is <span class="subst">$&#123;arg&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>webpack.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="comment">//其余配置省略</span></span><br><span class="line">    <span class="attr">devtool</span>:<span class="string">&quot;sourcce-map&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> (<span class="function">() =&gt;</span> &#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/******/</span> <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> __webpack_modules__ = (&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> <span class="string">&quot;./mySrc/js/tmp2.js&quot;</span>:</span><br><span class="line"><span class="comment">/*!**************************!*\</span></span><br><span class="line"><span class="comment">  !*** ./mySrc/js/tmp2.js ***!</span></span><br><span class="line"><span class="comment">  \**************************/</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function">(<span class="params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">__webpack_require__.<span class="title function_">r</span>(__webpack_exports__);</span><br><span class="line"><span class="comment">/* harmony export */</span> __webpack_require__.<span class="title function_">d</span>(__webpack_exports__, &#123;</span><br><span class="line"><span class="comment">/* harmony export */</span>   <span class="string">&quot;default&quot;</span>: <span class="function">() =&gt;</span> (<span class="comment">/* binding */</span> show)</span><br><span class="line"><span class="comment">/* harmony export */</span> &#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;show me!&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`arg is <span class="subst">$&#123;arg&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span> &#125;);</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// The module cache</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span> </span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// The require function</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">function</span> <span class="title function_">__webpack_require__</span>(<span class="params">moduleId</span>) &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// Check if module is in cache</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];</span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">if</span> (cachedModule !== <span class="literal">undefined</span>) &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">return</span> cachedModule.<span class="property">exports</span>;</span><br><span class="line"><span class="comment">/******/</span> &#125;</span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> <span class="variable language_">module</span> = __webpack_module_cache__[moduleId] = &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// no module.id needed</span></span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// no module.loaded needed</span></span><br><span class="line"><span class="comment">/******/</span> <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line"><span class="comment">/******/</span> &#125;;</span><br><span class="line"><span class="comment">/******/</span> </span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// Execute the module function</span></span><br><span class="line"><span class="comment">/******/</span> __webpack_modules__[moduleId](<span class="variable language_">module</span>, <span class="variable language_">module</span>.<span class="property">exports</span>, __webpack_require__);</span><br><span class="line"><span class="comment">/******/</span> </span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// Return the exports of the module</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line"><span class="comment">/******/</span> &#125;</span><br><span class="line"><span class="comment">/******/</span> </span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> <span class="comment">/* webpack/runtime/define property getters */</span></span><br><span class="line"><span class="comment">/******/</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// define getter functions for harmony exports</span></span><br><span class="line"><span class="comment">/******/</span> __webpack_require__.<span class="property">d</span> = <span class="function">(<span class="params"><span class="built_in">exports</span>, definition</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> definition) &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">if</span>(__webpack_require__.<span class="title function_">o</span>(definition, key) &amp;&amp; !__webpack_require__.<span class="title function_">o</span>(<span class="built_in">exports</span>, key)) &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, key, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">get</span>: definition[key] &#125;);</span><br><span class="line"><span class="comment">/******/</span> &#125;</span><br><span class="line"><span class="comment">/******/</span> &#125;</span><br><span class="line"><span class="comment">/******/</span> &#125;;</span><br><span class="line"><span class="comment">/******/</span> &#125;)();</span><br><span class="line"><span class="comment">/******/</span> </span><br><span class="line"><span class="comment">/******/</span> <span class="comment">/* webpack/runtime/hasOwnProperty shorthand */</span></span><br><span class="line"><span class="comment">/******/</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> __webpack_require__.<span class="property">o</span> = <span class="function">(<span class="params">obj, prop</span>) =&gt;</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(obj, prop))</span><br><span class="line"><span class="comment">/******/</span> &#125;)();</span><br><span class="line"><span class="comment">/******/</span> </span><br><span class="line"><span class="comment">/******/</span> <span class="comment">/* webpack/runtime/make namespace object */</span></span><br><span class="line"><span class="comment">/******/</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// define __esModule on exports</span></span><br><span class="line"><span class="comment">/******/</span> __webpack_require__.<span class="property">r</span> = <span class="function">(<span class="params"><span class="built_in">exports</span></span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title class_">Symbol</span>.<span class="property">toStringTag</span>) &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="title class_">Symbol</span>.<span class="property">toStringTag</span>, &#123; <span class="attr">value</span>: <span class="string">&#x27;Module&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">/******/</span> &#125;</span><br><span class="line"><span class="comment">/******/</span> <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">/******/</span> &#125;;</span><br><span class="line"><span class="comment">/******/</span> &#125;)();</span><br><span class="line"><span class="comment">/******/</span> </span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="keyword">var</span> __webpack_exports__ = &#123;&#125;;</span><br><span class="line"><span class="comment">// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.</span></span><br><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">/*!**************************!*\</span></span><br><span class="line"><span class="comment">  !*** ./mySrc/js/main.js ***!</span></span><br><span class="line"><span class="comment">  \**************************/</span></span><br><span class="line">__webpack_require__.<span class="title function_">r</span>(__webpack_exports__);</span><br><span class="line"><span class="comment">/* harmony import */</span> <span class="keyword">var</span> _tmp2__WEBPACK_IMPORTED_MODULE_0__ = <span class="title function_">__webpack_require__</span>(<span class="comment">/*! ./tmp2 */</span> <span class="string">&quot;./mySrc/js/tmp2.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>,_tmp2__WEBPACK_IMPORTED_MODULE_0__.<span class="property">default</span>)(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span> &#125;)()</span><br><span class="line">;</span><br><span class="line"><span class="comment">//# sourceMappingURL=build.js.map</span></span><br></pre></td></tr></table></figure><ul><li>看不懂不要紧，看完下面的分块分析，再看看整体代码</li></ul></li></ul><h3 id="关键分析"><a href="#关键分析" class="headerlink" title="关键分析"></a>关键分析</h3><ul><li>整体是一个立即执行函数（防止变量污染作用域）</li><li>内部先分析定义的一些函数</li><li>再分析模块数组</li><li>最后分析入口模块的执行</li></ul><h3 id="webpack-require-函数"><a href="#webpack-require-函数" class="headerlink" title="__webpack_require__函数"></a>__webpack_require__函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> <span class="comment">// The module cache</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span> </span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// The require function</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">function</span> <span class="title function_">__webpack_require__</span>(<span class="params">moduleId</span>) &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// Check if module is in cache</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];</span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">if</span> (cachedModule !== <span class="literal">undefined</span>) &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">return</span> cachedModule.<span class="property">exports</span>;</span><br><span class="line"><span class="comment">/******/</span> &#125;</span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> <span class="variable language_">module</span> = __webpack_module_cache__[moduleId] = &#123;</span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// no module.id needed</span></span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// no module.loaded needed</span></span><br><span class="line"><span class="comment">/******/</span> <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line"><span class="comment">/******/</span> &#125;;</span><br><span class="line"><span class="comment">/******/</span> </span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// Execute the module function</span></span><br><span class="line"><span class="comment">/******/</span> __webpack_modules__[moduleId](<span class="variable language_">module</span>, <span class="variable language_">module</span>.<span class="property">exports</span>, __webpack_require__);</span><br><span class="line"><span class="comment">/******/</span> </span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// Return the exports of the module</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line"><span class="comment">/******/</span> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>缓存优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;; <span class="comment">//缓存数组</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">var</span> cachedModule = __webpack_module_cache__[moduleId]; <span class="comment">//从缓存中找出模块</span></span><br><span class="line"><span class="keyword">if</span> (cachedModule !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedModule.<span class="property">exports</span>;<span class="comment">//如果找到了就直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>逻辑很简单的优化机制</li></ul></li><li><p>require 模仿</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">__webpack_require__</span>(<span class="params">moduleId</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 创建一个模块</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable language_">module</span> = (__webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">        <span class="comment">//同时创建了缓存</span></span><br><span class="line">        <span class="attr">exports</span>: &#123;&#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行模块代码</span></span><br><span class="line">    __webpack_modules__[moduleId](<span class="variable language_">module</span>, <span class="variable language_">module</span>.<span class="property">exports</span>, __webpack_require__);<span class="comment">//模块数组中每一个模块都是一个函数，下面会看到模块内部怎么对传入的module进行组装</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回模块抛出的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用于在浏览器中模仿commonjs或者ES6 module</li></ul></li></ul><h3 id="webpack-require-工具函数"><a href="#webpack-require-工具函数" class="headerlink" title="__webpack_require__工具函数"></a>__webpack_require__工具函数</h3><ul><li><p>hasOwnProperty 封装 __webpack_require__.o</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    __webpack_require__.<span class="property">o</span> = <span class="function">(<span class="params">obj, prop</span>) =&gt;</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(obj, prop);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>只是个简单的封装，功能基本不变</li></ul></li><li><p><strong>定义函数 __webpack_require__.d</strong></p><ul><li>核心功能函数，成功模仿Commonjs规范，抛出了模块</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 即将抛出的exports上定义代码</span></span><br><span class="line">    __webpack_require__.<span class="property">d</span> = <span class="function">(<span class="params"><span class="built_in">exports</span>, definition</span>) =&gt;</span> &#123;<span class="comment">//传入exports和定义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> definition) &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                __webpack_require__.<span class="title function_">o</span>(definition, key) &amp;&amp;</span><br><span class="line">                !__webpack_require__.<span class="title function_">o</span>(<span class="built_in">exports</span>, key)</span><br><span class="line">            ) <span class="comment">//上面提到的封装函数，判定属性是否存在以及是否发生覆盖</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, key, &#123;</span><br><span class="line">                    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">get</span>: definition[key],</span><br><span class="line">                &#125;);<span class="comment">//exports上定义getter，也就是module.exports访问时，利用get定位到模块中抛出的同名属性</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>结合下面的模块解析会更清晰</li></ul></li><li><p>标记函数 __webpack_require__.r</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 标记这是个模块</span></span><br><span class="line">    __webpack_require__.<span class="property">r</span> = <span class="function">(<span class="params"><span class="built_in">exports</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Symbol</span> !== <span class="string">&quot;undefined&quot;</span> &amp;&amp; <span class="title class_">Symbol</span>.<span class="property">toStringTag</span>) &#123;<span class="comment">//Symbol.toStringTag可以修改typeof的返回值</span></span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="title class_">Symbol</span>.<span class="property">toStringTag</span>, &#123; <span class="attr">value</span>: <span class="string">&quot;Module&quot;</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);<span class="comment">//不支持Symbol的替代品</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul><h3 id="模块数组"><a href="#模块数组" class="headerlink" title="模块数组"></a>模块数组</h3><ul><li><p>此处只有一个依赖模块（main.js作为入口模块，webpack5不归类为模块数组）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __webpack_modules__ = &#123;</span><br><span class="line">    <span class="comment">/***/</span> <span class="string">&quot;./mySrc/js/tmp2.js&quot;</span>:<span class="comment">//本身是个键值对,键就是引用路径,值是一个函数</span></span><br><span class="line">    <span class="comment">/*!**************************!*\</span></span><br><span class="line"><span class="comment">  !*** ./mySrc/js/tmp2.js ***!</span></span><br><span class="line"><span class="comment">  \**************************/</span></span><br><span class="line">    <span class="comment">/***/</span> <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        __unused_webpack_module,</span></span></span><br><span class="line"><span class="params"><span class="function">        __webpack_exports__,</span></span></span><br><span class="line"><span class="params"><span class="function">        __webpack_require__</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) =&gt;</span> &#123;</span><br><span class="line">        __webpack_require__.<span class="title function_">r</span>(__webpack_exports__);<span class="comment">//首先标记模块</span></span><br><span class="line">        <span class="comment">/* harmony export */</span> __webpack_require__.<span class="title function_">d</span>(__webpack_exports__, &#123;</span><br><span class="line">            <span class="comment">/* harmony export */</span> <span class="attr">default</span>: <span class="function">() =&gt;</span> <span class="comment">/* binding */</span> show,</span><br><span class="line">            <span class="comment">/* harmony export */</span></span><br><span class="line">        &#125;);<span class="comment">//这一步利用定义函数，将本模块抛出的属性定义在module.exports上，从而使外部能够正常访问</span></span><br><span class="line">        <span class="comment">//下面就是源代码</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;show me!&quot;</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`arg is <span class="subst">$&#123;arg&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/***/</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="入口模块"><a href="#入口模块" class="headerlink" title="入口模块"></a>入口模块</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/*!**************************!*\</span></span><br><span class="line"><span class="comment">  !*** ./mySrc/js/main.js ***!</span></span><br><span class="line"><span class="comment">  \**************************/</span></span><br><span class="line">    <span class="comment">/* harmony import */</span> <span class="keyword">var</span> _tmp2__WEBPACK_IMPORTED_MODULE_0__ = <span class="title function_">__webpack_require__</span>(</span><br><span class="line">        <span class="comment">/*! ./tmp2 */</span> <span class="string">&quot;./mySrc/js/tmp2.js&quot;</span></span><br><span class="line">    );<span class="comment">//利用__webpack_require__函数模仿require读取了tmp2模块</span></span><br><span class="line"></span><br><span class="line">    (<span class="number">0</span>, _tmp2__WEBPACK_IMPORTED_MODULE_0__.<span class="property">default</span>)(<span class="number">123</span>);<span class="comment">//调用tmp2抛出的show函数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1111&quot;</span>);<span class="comment">//入口源代码</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>关键是 __webpack_require__ 函数成功返回了模块抛出的属性，这一点必须理解，之后的内容就很简单了</li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动实现一个简单的Promise</title>
      <link href="/2021/05/19/wirteMyPromise/"/>
      <url>/2021/05/19/wirteMyPromise/</url>
      
        <content type="html"><![CDATA[<ul><li><p>自定义的promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myPromise</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;pending&#x27;</span>; <span class="comment">//记录状态，只有三种可能pending resolved rejected</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = <span class="literal">null</span>; <span class="comment">//promise携带值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span> = []; <span class="comment">//待调用的回调函数，pending状态下调用then时需要 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolve</span> = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123; <span class="comment">//保证状态确定后不会改变</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;resolved&#x27;</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">            <span class="comment">//状态变化后，取出所有待调用的回调函数，进行处理。例如：then的第一个回调函数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span>[i](val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reject</span> = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123; <span class="comment">//保证状态确定后不会改变</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">val</span> = reason;</span><br><span class="line">            <span class="comment">//和resolve类似</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>[i](reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">then</span> = <span class="function">(<span class="params">resolveFn, rejectFn</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//promise值穿透，并保证默认处理函数</span></span><br><span class="line">        resolveFn = <span class="keyword">typeof</span> resolveFn === <span class="string">&#x27;function&#x27;</span> ? resolveFn : <span class="keyword">function</span> (<span class="params">v</span>) &#123; <span class="keyword">return</span> v &#125;;</span><br><span class="line">        rejectFn = <span class="keyword">typeof</span> rejectFn === <span class="string">&#x27;function&#x27;</span> ? rejectFn : <span class="keyword">function</span> (<span class="params">r</span>) &#123; <span class="keyword">return</span> r &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;resolved&#x27;</span>) &#123; <span class="comment">//调用then时状态是resolved</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">//then永远返回一个promise，用于链式调用</span></span><br><span class="line">                <span class="keyword">try</span> &#123; <span class="comment">//try捕获错误，用来reject</span></span><br><span class="line">                    <span class="keyword">let</span> next = <span class="title function_">resolveFn</span>(<span class="variable language_">this</span>.<span class="property">val</span>); <span class="comment">//调用用户自定义的resolve处理函数，把值传出去，并获取用户返回的值</span></span><br><span class="line">                    <span class="keyword">if</span> (next <span class="keyword">instanceof</span> myPromise) &#123; <span class="comment">//resolve处理函数返回的是promise时，调用then解包</span></span><br><span class="line">                        next.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">                        <span class="comment">//注意，此处将外部（then函数定义）即将返回的promise的resolve传入了用户自定义的resolve处理函数返回的promise中，当用户的promise状态改变时，就会调用此处的resolve并将值传给外部的promise，从而可以使用最外部的then接收，构成返回 new promise 的promise链式调用</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="title function_">resolve</span>(next) <span class="comment">//否则直接resolve用户传进来的值</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="title function_">rejectFn</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123; <span class="comment">//reject的状态，逻辑和上面差不多</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> next = <span class="title function_">rejectFn</span>(<span class="variable language_">this</span>.<span class="property">val</span>);</span><br><span class="line">                    <span class="keyword">if</span> (next <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">                        next.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="title function_">rejectFn</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123; <span class="comment">//调用then时，状态未确定</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//由于状态未确定，先把状态确定时要执行的逻辑保存起来，等到状态确定时，执行</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">onResolvedCallback</span>.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params">val</span>) &#123; <span class="comment">//resolved逻辑保存</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> next = <span class="title function_">resolveFn</span>(val);</span><br><span class="line">                        <span class="keyword">if</span> (next <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">                            next.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">                        &#125;;</span><br><span class="line">                        <span class="title function_">resolve</span>(next);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        <span class="title function_">reject</span>(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123; <span class="comment">//reject逻辑保存</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> next = <span class="title function_">rejectFn</span>(reason);</span><br><span class="line">                        <span class="keyword">if</span> (next <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">                            next.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="title function_">reject</span>(next)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        <span class="title function_">reject</span>(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">//尝试执行promise构造函数的代码，并将自身定义好的resolve,reject传入</span></span><br><span class="line">        <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>, <span class="variable language_">this</span>.<span class="property">reject</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">reject</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试样例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>异步throw无法捕获</li><li>通过this定义函数，导致每个promise实例不共用方法，性能影响</li></ul></li><li><p>all,race手写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">myAll</span> = <span class="function">(<span class="params">promiseArr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>, all = promiseArr.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">let</span> resArr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; all; i++) &#123;</span><br><span class="line">            promiseArr[i].<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">                resArr[i] = val;</span><br><span class="line">                <span class="keyword">if</span> (count === all) &#123; <span class="comment">//主要通过promise数量确定是否结束</span></span><br><span class="line">                    <span class="title function_">resolve</span>(resArr)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//race更简单 待会写....</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
